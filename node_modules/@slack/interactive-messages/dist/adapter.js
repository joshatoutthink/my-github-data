'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SlackMessageAdapter = exports.errorCodes = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * @module adapter
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _axios = require('axios');

var _axios2 = _interopRequireDefault(_axios);

var _lodash = require('lodash.isstring');

var _lodash2 = _interopRequireDefault(_lodash);

var _lodash3 = require('lodash.isplainobject');

var _lodash4 = _interopRequireDefault(_lodash3);

var _lodash5 = require('lodash.isregexp');

var _lodash6 = _interopRequireDefault(_lodash5);

var _lodash7 = require('lodash.isfunction');

var _lodash8 = _interopRequireDefault(_lodash7);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _httpHandler = require('./http-handler');

var _util = require('./util');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = (0, _debug2.default)('@slack/interactive-messages:adapter');

var errorCodes = exports.errorCodes = {
  BODY_PARSER_NOT_PERMITTED: 'SLACKADAPTER_BODY_PARSER_NOT_PERMITTED_FAILURE'
};

/**
 * Transforms various forms of matching constraints to a single standard object shape
 * @param {string|RegExp|Object} matchingConstraints - the various forms of matching constraints
 * accepted
 * @returns {Object} - an object where each matching constraint is a property
 * @private
 */
function formatMatchingConstraints(matchingConstraints) {
  var ret = {};
  if (typeof matchingConstraints === 'undefined' || matchingConstraints === null) {
    throw new TypeError('Constraints cannot be undefined or null');
  }
  if (!(0, _lodash4.default)(matchingConstraints)) {
    ret.callbackId = matchingConstraints;
  } else {
    ret = Object.assign({}, matchingConstraints);
  }
  return ret;
}

/**
 * Validates general properties of a matching constraints object
 * @param {Object} matchingConstraints - object describing the constraints on a callback
 * @returns {Error|false} - a false value represents successful validation, otherwise an error to
 * describe why validation failed.
 * @private
 */
function validateConstraints(matchingConstraints) {
  if (matchingConstraints.callbackId && !((0, _lodash2.default)(matchingConstraints.callbackId) || (0, _lodash6.default)(matchingConstraints.callbackId))) {
    return new TypeError('Callback ID must be a string or RegExp');
  }

  if (matchingConstraints.blockId && !((0, _lodash2.default)(matchingConstraints.blockId) || (0, _lodash6.default)(matchingConstraints.blockId))) {
    return new TypeError('Block ID must be a string or RegExp');
  }

  if (matchingConstraints.actionId && !((0, _lodash2.default)(matchingConstraints.actionId) || (0, _lodash6.default)(matchingConstraints.actionId))) {
    return new TypeError('Action ID must be a string or RegExp');
  }

  return false;
}

/**
 * Validates properties of a matching constraints object specific to registering an options request
 * @param {Object} matchingConstraints - object describing the constraints on a callback
 * @returns {Error|false} - a false value represents successful validation, otherwise an error to
 * describe why validation failed.
 * @private
 */
function validateOptionsConstraints(optionsConstraints) {
  if (optionsConstraints.within && !(optionsConstraints.within === 'interactive_message' || optionsConstraints.within === 'block_actions' || optionsConstraints.within === 'dialog')) {
    return new TypeError('Within must be \'block_actions\', \'interactive_message\' or \'dialog\'');
  }

  // We don't need to validate unfurl, we'll just cooerce it to a boolean
  return false;
}

/**
 * An adapter for Slack's interactive message components such as buttons, menus, and dialogs.
 * @typicalname slackInteractions
 */

var SlackMessageAdapter = exports.SlackMessageAdapter = function () {
  /**
   * Create a message adapter.
   *
   * @param {string} signingSecret - Slack app signing secret used to authenticate request
   * @param {Object} [options]
   * @param {number} [options.syncResponseTimeout=2500] - number of milliseconds to wait before
   * flushing a syncrhonous response to an incoming request and falling back to an asynchronous
   * response.
   * @param {boolean} [options.lateResponseFallbackEnabled=true] - whether or not promises that
   * resolve after the syncResponseTimeout can fallback to a request for the response_url. this only
   * works in cases where the semantic meaning of the response and the response_url are the same.
   */
  function SlackMessageAdapter(signingSecret) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$syncResponseTime = _ref.syncResponseTimeout,
        syncResponseTimeout = _ref$syncResponseTime === undefined ? 2500 : _ref$syncResponseTime,
        _ref$lateResponseFall = _ref.lateResponseFallbackEnabled,
        lateResponseFallbackEnabled = _ref$lateResponseFall === undefined ? true : _ref$lateResponseFall;

    _classCallCheck(this, SlackMessageAdapter);

    if (!(0, _lodash2.default)(signingSecret)) {
      throw new TypeError('SlackMessageAdapter needs a signing secret');
    }

    if (syncResponseTimeout > 3000 || syncResponseTimeout < 1) {
      throw new TypeError('syncResponseTimeout must be between 1 and 3000');
    }

    this.signingSecret = signingSecret;
    this.syncResponseTimeout = syncResponseTimeout;
    this.lateResponseFallbackEnabled = lateResponseFallbackEnabled;
    this.callbacks = [];
    this.axios = _axios2.default.create({
      headers: {
        'User-Agent': (0, _util.packageIdentifier)()
      }
    });

    debug('instantiated');
  }

  /* Interface for using the built-in server */

  /**
   * Create a server that dispatches Slack's interactive message actions and menu requests to this
   * message adapter instance. Use this method if your application will handle starting the server.
   *
   * @param {string} [path=/slack/actions] - The path portion of the URL where the server will
   * listen for requests from Slack's interactive messages.
   * @returns {Promise<NodeHttpServer>} - A promise that resolves to an instance of http.Server and
   * will dispatch interactive message actions and options requests to this message adapter
   * instance. https://nodejs.org/dist/latest/docs/api/http.html#http_class_http_server
   */


  _createClass(SlackMessageAdapter, [{
    key: 'createServer',
    value: function createServer() {
      var _this = this;

      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '/slack/actions';

      // TODO: more options (like https)
      return Promise.resolve().then(function () {
        debug('server created - path: %s', path);

        return _http2.default.createServer(_this.requestListener());
      });
    }

    /**
     * Start a built-in server that dispatches Slack's interactive message actions and menu requests
     * to this message adapter interface.
     *
     * @param {number} port
     * @returns {Promise<void>} - A promise that resolves once the server is ready
     */

  }, {
    key: 'start',
    value: function start(port) {
      var _this2 = this;

      return this.createServer().then(function (server) {
        return new Promise(function (resolve, reject) {
          _this2.server = server;
          server.on('error', reject);
          server.listen(port, function () {
            return resolve(server);
          });
          debug('server started - port: %s', port);
        });
      });
    }

    /**
     * Stop the previously started built-in server.
     *
     * @returns {Promise<void>} - A promise that resolves once the server is cleaned up.
     */

  }, {
    key: 'stop',
    value: function stop() {
      var _this3 = this;

      return new Promise(function (resolve, reject) {
        if (_this3.server) {
          _this3.server.close(function (error) {
            delete _this3.server;
            if (error) {
              reject(error);
            } else {
              resolve();
            }
          });
        } else {
          reject(new Error('SlackMessageAdapter cannot stop when it did not start a server'));
        }
      });
    }

    /* Interface for bringing your own server */

    /**
     * Create a middleware function that can be used to integrate with the `express` web framework
     * in order for incoming requests to be dispatched to this message adapter instance.
     *
     * @returns {ExpressMiddlewareFunc} - A middleware function http://expressjs.com/en/guide/using-middleware.html
     */

  }, {
    key: 'expressMiddleware',
    value: function expressMiddleware() {
      var requestListener = this.requestListener();
      return function (req, res, next) {
        // If parser is being used, we can't verify request signature
        if (req.body) {
          var error = new Error('Parsing request body prohibits request signature verification');
          error.code = errorCodes.BODY_PARSER_NOT_PERMITTED;
          next(error);
          return;
        }
        requestListener(req, res);
      };
    }

    /**
     * Create a request listener function that handles HTTP requests, verifies requests
     * and dispatches responses
     *
     * @returns {slackRequestListener}
     */

  }, {
    key: 'requestListener',
    value: function requestListener() {
      return (0, _httpHandler.createHTTPHandler)(this);
    }

    /* Interface for adding handlers */

    /* eslint-disable max-len */
    /**
     * Add a handler for an interactive message action.
     *
     * Usually there's no need to be concerned with _how_ a message is sent to Slack, but the
     * following table describes it fully.
     *
     * **Action**|**Return `object`**|**Return `Promise<object>`**|**Return `undefined`**|**Call `respond(message)`**|**Notes**
     * :-----:|:-----:|:-----:|:-----:|:-----:|:-----:
     * **Button Press**| Message in response | When resolved before `syncResposeTimeout` or `lateResponseFallbackEnabled: false`, message in response<br />When resolved after `syncResponseTimeout` and `lateResponseFallbackEnabled: true`, message in request to `response_url` | Empty response | Message in request to `response_url` | Create a new message instead of replacing using `replace_original: false`
     * **Menu Selection**| Message in response | When resolved before `syncResposeTimeout` or `lateResponseFallbackEnabled: false`, message in response<br />When resolved after `syncResponseTimeout` and `lateResponseFallbackEnabled: true`, message in request to `response_url` | Empty response | Message in request to `response_url` | Create a new message instead of replacing using `replace_original: false`
     * **Message Action** | Message in response | When resolved before `syncResposeTimeout` or `lateResponseFallbackEnabled: false`, message in response<br />When resolved after `syncResponseTimeout` and `lateResponseFallbackEnabled: true`, message in request to `response_url` | Empty response | Message in request to `response_url` |
     * **Dialog Submission**| Error list in response | Error list in response | Empty response | Message in request to `response_url` | Returning a Promise that takes longer than 3 seconds to resolve can result in the user seeing an error. Warning logged if a promise isn't completed before `syncResponseTimeout`.
     *
     * @param {Object|string|RegExp} matchingConstraints - the callback ID (as a string or RegExp) or
     * an object describing the constraints to match actions for the handler.
     * @param {string|RegExp} [matchingConstraints.callbackId] - a string or RegExp to match against
     * the `callback_id`
     * @param {string|RegExp} [matchingConstraints.blockId] - a string or RegExp to match against
     * the `block_id`
     * @param {string|RegExp} [matchingConstraints.actionId] - a string or RegExp to match against
     * the `action_id`
     * @param {string} [matchingConstraints.type] - valid types include all
     * [actions block elements](https://api.slack.com/reference/messaging/interactive-components),
     * `select` only for menu selections, or `dialog_submission` only for dialog submissions
     * @param {boolean} [matchingConstraints.unfurl] - when `true` only match actions from an unfurl
     * @param {module:adapter~SlackMessageAdapter~ActionHandler} callback - the function to run when
     * an action is matched
     * @returns {module:adapter~SlackMessageAdapter} - this instance (for chaining)
     */

  }, {
    key: 'action',
    value: function action(matchingConstraints, callback) {
      /* eslint-enable max-len */
      var actionConstraints = formatMatchingConstraints(matchingConstraints);
      actionConstraints.handlerType = 'action';

      var error = validateConstraints(actionConstraints);
      if (error) {
        debug('action could not be registered: %s', error.message);
        throw error;
      }

      return this.registerCallback(actionConstraints, callback);
    }

    /* eslint-disable max-len */
    /**
     * Add a handler for an options request
     *
     * Usually there's no need to be concerned with _how_ a message is sent to Slack, but the
     * following table describes it fully
     *
     * &nbsp;|**Return `options`**|**Return `Promise<options>`**|**Return `undefined`**|**Notes**
     * :-----:|:-----:|:-----:|:-----:|:-----:
     * **Options Request**| Options in response | Options in response | Empty response | Returning a Promise that takes longer than 3 seconds to resolve can result in the user seeing an error. If the request is from within a dialog, the `text` field is called `label`.
     *
     * @param {object} matchingConstraints - the callback ID (as a string or RegExp) or
     * an object describing the constraints to select options requests for the handler.
     * @param {string|RegExp} [matchingConstraints.callbackId] - a string or RegExp to match against
     * the `callback_id`
     * @param {string|RegExp} [matchingConstraints.blockId] - a string or RegExp to match against
     * the `block_id`
     * @param {string|RegExp} [matchingConstraints.actionId] - a string or RegExp to match against
     * the `action_id`
     * @param {string} [matchingConstraints.within] - `block_actions` only for external select
     * in actions block, `interactive_message` only for menus in an interactive message, or
     * `dialog` only for menus in a dialog
     * @param {module:adapter~SlackMessageAdapter~OptionsHandler} callback - the function to run when
     * an options request is matched
     * @returns {module:adapter~SlackMessageAdapter} - this instance (for chaining)
     */

  }, {
    key: 'options',
    value: function options(matchingConstraints, callback) {
      /* eslint-enable max-len */
      var optionsConstraints = formatMatchingConstraints(matchingConstraints);
      optionsConstraints.handlerType = 'options';

      var error = validateConstraints(optionsConstraints) || validateOptionsConstraints(optionsConstraints);
      if (error) {
        debug('options could not be registered: %s', error.message);
        throw error;
      }

      return this.registerCallback(optionsConstraints, callback);
    }

    /* Interface for HTTP servers (like express middleware) */

    /**
     * Dispatches the contents of an HTTP request to the registered handlers.
     *
     * @param {object} payload
     * @returns {Promise<{ status: number, content: object|string|undefined }>|undefined} - A promise
     * of the response information (an object with status and content that is a JSON serializable
     * object or a string or undefined) for the request. An undefined return value indicates that the
     * request was not matched.
     * @private
     */

  }, {
    key: 'dispatch',
    value: function dispatch(payload) {
      var _this4 = this;

      var callback = this.matchCallback(payload);
      if (!callback) {
        debug('dispatch could not find a handler');
        return undefined;
      }
      debug('dispatching to handler');

      var _callback = _slicedToArray(callback, 2),
          callbackFn = _callback[1];

      // when a response_url is present,`respond()` function created to to send a message using it


      var respond = void 0;
      if (payload.response_url) {
        respond = function respond(message) {
          if (typeof message.then === 'function') {
            throw new TypeError('Cannot use a Promise as the parameter for respond()');
          }
          debug('sending async response');
          return _this4.axios.post(payload.response_url, message);
        };
      }

      var callbackResult = void 0;
      try {
        callbackResult = callbackFn.call(this, payload, respond);
      } catch (error) {
        debug('callback error: %o', error);
        return Promise.resolve({ status: 500 });
      }

      if (callbackResult) {
        return (0, _util.promiseTimeout)(this.syncResponseTimeout, callbackResult).then(function (content) {
          return { status: 200, content };
        }).catch(function (error) {
          if (error.code === _util.errorCodes.PROMISE_TIMEOUT) {
            // warn and continue for promises that cannot be saved with a later async response.
            // this includes dialog submissions because the response_url doesn't have the same
            // semantics as the response, any request that doesn't contain a response_url, and
            // if this has been explicitly disabled in the configuration.
            if (!_this4.lateResponseFallbackEnabled || !respond || payload.type === 'dialog_submission') {
              debug('WARNING: The response Promise did not resolve under the timeout.');
              return callbackResult.then(function (content) {
                return { status: 200, content };
              }).catch(function () {
                return { status: 500 };
              });
            }

            // save a late promise by sending an empty body in the response, and then use the
            // response_url to send the eventually resolved value
            callbackResult.then(respond).catch(function (callbackError) {
              // when the promise is late and fails, we cannot do anything but log it
              debug('ERROR: Promise was late and failed. Use `.catch()` to handle errors.');
              throw callbackError;
            });
            return { status: 200 };
          }

          return { status: 500 };
        });
      }

      // The following result value represents:
      // * "no replacement" for message actions
      // * "submission is valid" for dialog submissions
      // * "no suggestions" for menu options TODO: check that this is true
      return Promise.resolve({ status: 200 });
    }

    /**
     * @private
     */

  }, {
    key: 'registerCallback',
    value: function registerCallback(constraints, callback) {
      // Validation
      if (!(0, _lodash8.default)(callback)) {
        debug('did not register callback because its not a function');
        throw new TypeError('callback must be a function');
      }

      this.callbacks.push([constraints, callback]);

      return this;
    }

    /**
     * @private
     */

  }, {
    key: 'matchCallback',
    value: function matchCallback(payload) {
      return this.callbacks.find(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 1),
            constraints = _ref3[0];

        // if the callback ID constraint is specified, only continue if it matches
        if (constraints.callbackId) {
          if ((0, _lodash2.default)(constraints.callbackId) && payload.callback_id !== constraints.callbackId) {
            return false;
          }
          if ((0, _lodash6.default)(constraints.callbackId) && !constraints.callbackId.test(payload.callback_id)) {
            return false;
          }
        }

        // if the action constraint is specified, only continue if it matches
        if (constraints.handlerType === 'action') {
          // a payload that represents an action either has actions, submission, or message defined
          if (!(payload.actions || payload.submission || payload.message)) {
            return false;
          }

          // dialog submissions don't have an action defined, so an empty action is substituted for
          // the purpose of callback matching
          var action = payload.actions ? payload.actions[0] : {};

          // if the block ID constraint is specified, only continue if it matches
          if (constraints.blockId) {
            if ((0, _lodash2.default)(constraints.blockId) && action.block_id !== constraints.blockId) {
              return false;
            }
            if ((0, _lodash6.default)(constraints.blockId) && !constraints.blockId.test(action.block_id)) {
              return false;
            }
          }

          // if the action ID constraint is specified, only continue if it matches
          if (constraints.actionId) {
            if ((0, _lodash2.default)(constraints.actionId) && action.action_id !== constraints.actionId) {
              return false;
            }
            if ((0, _lodash6.default)(constraints.actionId) && !constraints.actionId.test(action.action_id)) {
              return false;
            }
          }

          // button and message actions have a type defined inside the action, dialog submission
          // actions have a type defined at the top level, and select actions don't have a type
          // defined, but type can be inferred by checking if a `selected_options` property exists in
          // the action.
          var type = action.type || payload.type || action.selected_options && 'select';
          if (!type) {
            debug('no type found in dispatched action');
          }
          // if the type constraint is specified, only continue if it matches
          if (constraints.type && constraints.type !== type) {
            return false;
          }

          // if the unfurl constraint is specified, only continue if it matches
          if ('unfurl' in constraints && (constraints.unfurl && !payload.is_app_unfurl || !constraints.unfurl && payload.is_app_unfurl)) {
            return false;
          }
        }

        if (constraints.handlerType === 'options') {
          // a payload that represents an options request in attachments always has a name defined
          // at the top level. in blocks the type is block_suggestion and has no name
          if (!('name' in payload || payload.type && payload.type === 'block_suggestion')) {
            return false;
          }

          // if the block ID constraint is specified, only continue if it matches
          if (constraints.blockId) {
            if ((0, _lodash2.default)(constraints.blockId) && payload.block_id !== constraints.blockId) {
              return false;
            }
            if ((0, _lodash6.default)(constraints.blockId) && !constraints.blockId.test(payload.block_id)) {
              return false;
            }
          }

          // if the action ID constraint is specified, only continue if it matches
          if (constraints.actionId) {
            if ((0, _lodash2.default)(constraints.actionId) && payload.action_id !== constraints.actionId) {
              return false;
            }
            if ((0, _lodash6.default)(constraints.actionId) && !constraints.actionId.test(payload.action_id)) {
              return false;
            }
          }

          // an options request always has a type at the top level which can be one of three values
          // that need to be mapped into the values for the `within` constraint:
          // * type:interactive_message => within:interactive_message
          // * type:block_suggestion => within:block_actions
          // * type:dialog_suggestion => within:dialog
          if (constraints.within) {
            if (constraints.within === 'interactive_message' && payload.type !== 'interactive_message') {
              return false;
            }
            if (constraints.within === 'block_actions' && payload.type !== 'block_suggestion') {
              return false;
            }
            if (constraints.within === 'dialog' && payload.type !== 'dialog_suggestion') {
              return false;
            }
          }
        }

        // if there's no reason to eliminate this callback, then its a match!
        return true;
      });
    }
  }]);

  return SlackMessageAdapter;
}();

/**
 * @alias module:adapter
 */


exports.default = SlackMessageAdapter;

/**
 * @external ExpressMiddlewareFunc
 * @see http://expressjs.com/en/guide/using-middleware.html
 */

/**
 * @external NodeHttpServer
 * @see https://nodejs.org/dist/latest/docs/api/http.html#http_class_http_server
 */

/**
 * A handler function for action requests (block actions, button presses, menu selections,
 * and dialog submissions).
 *
 * @name module:adapter~SlackMessageAdapter~ActionHandler
 * @function
 * @param {Object} payload - an object describing the
 * [block actions](https://api.slack.com/messaging/interactivity/enabling#understanding-payloads)
 * [button press](https://api.slack.com/docs/message-buttons#responding_to_message_actions),
 * [menu selection](https://api.slack.com/docs/message-menus#request_url_response), or
 * [dialog submission](https://api.slack.com/dialogs#evaluating_submission_responses).
 * @param {module:adapter~SlackMessageAdapter~ActionHandler~Respond} respond - When the action is a
 * button press or menu selection, this function is used to update the message where the action
 * occured or create new messages in the same conversation. When the action is a dialog submission,
 * this function is used to create new messages in the conversation where the dialog was triggered.
 * @returns {Object} When the action is a button press or a menu selection, this object is a
 * replacement
 * [message](https://api.slack.com/docs/interactive-message-field-guide#top-level_message_fields)
 * for the message in which the action occurred. It may also be a Promise for a message, and if so
 * and the Promise takes longer than the `syncResponseTimeout` to complete, the message is sent over
 * the `response_url`. The message may also be a new message in the same conversation by setting
 * `replace_original: false`. When the action is a dialog submission, this object is a list of
 * [validation errors](https://api.slack.com/dialogs#input_validation). It may also be a Promise for
 * a list of validation errors, and if so and the Promise takes longer than the
 * `syncReponseTimeout` to complete, Slack will disply an error to the user. If there is no return
 * value, then button presses and menu selections do not update the message and dialog submissions
 * will validate and dismiss.
 */

/**
 * A function used to send message updates after an action is handled. This function can be used
 * up to 5 times in 30 minutes.
 *
 * @name module:adapter~SlackMessageAdapter~ActionHandler~Respond
 * @function
 * @param {Object} message - a
 * [message](https://api.slack.com/docs/interactive-message-field-guide#top-level_message_fields).
 * Dialog submissions do not allow `resplace_original: false` on this message.
 * @returns {Promise} there's no contract or interface for the resolution value, but this Promise
 * will resolve when the HTTP response from the `response_url` request is complete and reject when
 * there is an error.
 */

/**
 * A handler function for menu options requests.
 *
 * @name module:adapter~SlackMessageAdapter~OptionsHandler
 * @function
 * @param {Object} payload - an object describing
 * [the state of the menu](https://api.slack.com/docs/message-menus#options_load_url)
 * @returns {Object} an
 * [options list](https://api.slack.com/docs/interactive-message-field-guide#option_fields) or
 * [option groups list](https://api.slack.com/docs/interactive-message-field-guide#option_groups).
 * When the menu is within an interactive message, (`within: 'interactive_message'`) the option
 * keys are `text` and `value`. When the menu is within a dialog (`within: 'dialog'`) the option
 * keys are `label` and `value`. When the menu is within a dialog (`within: 'block_actions'`) the
 * option keys are a text block and `value`. This function may also return a Promise either of
 * these values. If a Promise is returned and it does not complete within 3 seconds, Slack will
 * display an error to the user. If there is no return value, then the user is shown an empty list
 * of options.
 */
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9hZGFwdGVyLmpzIl0sIm5hbWVzIjpbImRlYnVnIiwiZXJyb3JDb2RlcyIsIkJPRFlfUEFSU0VSX05PVF9QRVJNSVRURUQiLCJmb3JtYXRNYXRjaGluZ0NvbnN0cmFpbnRzIiwibWF0Y2hpbmdDb25zdHJhaW50cyIsInJldCIsIlR5cGVFcnJvciIsImNhbGxiYWNrSWQiLCJPYmplY3QiLCJhc3NpZ24iLCJ2YWxpZGF0ZUNvbnN0cmFpbnRzIiwiYmxvY2tJZCIsImFjdGlvbklkIiwidmFsaWRhdGVPcHRpb25zQ29uc3RyYWludHMiLCJvcHRpb25zQ29uc3RyYWludHMiLCJ3aXRoaW4iLCJTbGFja01lc3NhZ2VBZGFwdGVyIiwic2lnbmluZ1NlY3JldCIsInN5bmNSZXNwb25zZVRpbWVvdXQiLCJsYXRlUmVzcG9uc2VGYWxsYmFja0VuYWJsZWQiLCJjYWxsYmFja3MiLCJheGlvcyIsImNyZWF0ZSIsImhlYWRlcnMiLCJwYXRoIiwiUHJvbWlzZSIsInJlc29sdmUiLCJ0aGVuIiwiaHR0cCIsImNyZWF0ZVNlcnZlciIsInJlcXVlc3RMaXN0ZW5lciIsInBvcnQiLCJyZWplY3QiLCJzZXJ2ZXIiLCJvbiIsImxpc3RlbiIsImNsb3NlIiwiZXJyb3IiLCJFcnJvciIsInJlcSIsInJlcyIsIm5leHQiLCJib2R5IiwiY29kZSIsImNhbGxiYWNrIiwiYWN0aW9uQ29uc3RyYWludHMiLCJoYW5kbGVyVHlwZSIsIm1lc3NhZ2UiLCJyZWdpc3RlckNhbGxiYWNrIiwicGF5bG9hZCIsIm1hdGNoQ2FsbGJhY2siLCJ1bmRlZmluZWQiLCJjYWxsYmFja0ZuIiwicmVzcG9uZCIsInJlc3BvbnNlX3VybCIsInBvc3QiLCJjYWxsYmFja1Jlc3VsdCIsImNhbGwiLCJzdGF0dXMiLCJjb250ZW50IiwiY2F0Y2giLCJ1dGlsRXJyb3JDb2RlcyIsIlBST01JU0VfVElNRU9VVCIsInR5cGUiLCJjYWxsYmFja0Vycm9yIiwiY29uc3RyYWludHMiLCJwdXNoIiwiZmluZCIsImNhbGxiYWNrX2lkIiwidGVzdCIsImFjdGlvbnMiLCJzdWJtaXNzaW9uIiwiYWN0aW9uIiwiYmxvY2tfaWQiLCJhY3Rpb25faWQiLCJzZWxlY3RlZF9vcHRpb25zIiwidW5mdXJsIiwiaXNfYXBwX3VuZnVybCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O3FqQkFBQTs7OztBQUlBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7O0FBQ0E7Ozs7OztBQUVBLElBQU1BLFFBQVEscUJBQWEscUNBQWIsQ0FBZDs7QUFFTyxJQUFNQyxrQ0FBYTtBQUN4QkMsNkJBQTJCO0FBREgsQ0FBbkI7O0FBSVA7Ozs7Ozs7QUFPQSxTQUFTQyx5QkFBVCxDQUFtQ0MsbUJBQW5DLEVBQXdEO0FBQ3RELE1BQUlDLE1BQU0sRUFBVjtBQUNBLE1BQUksT0FBT0QsbUJBQVAsS0FBK0IsV0FBL0IsSUFBOENBLHdCQUF3QixJQUExRSxFQUFnRjtBQUM5RSxVQUFNLElBQUlFLFNBQUosQ0FBYyx5Q0FBZCxDQUFOO0FBQ0Q7QUFDRCxNQUFJLENBQUMsc0JBQWNGLG1CQUFkLENBQUwsRUFBeUM7QUFDdkNDLFFBQUlFLFVBQUosR0FBaUJILG1CQUFqQjtBQUNELEdBRkQsTUFFTztBQUNMQyxVQUFNRyxPQUFPQyxNQUFQLENBQWMsRUFBZCxFQUFrQkwsbUJBQWxCLENBQU47QUFDRDtBQUNELFNBQU9DLEdBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9BLFNBQVNLLG1CQUFULENBQTZCTixtQkFBN0IsRUFBa0Q7QUFDaEQsTUFBSUEsb0JBQW9CRyxVQUFwQixJQUNBLEVBQUUsc0JBQVNILG9CQUFvQkcsVUFBN0IsS0FBNEMsc0JBQVNILG9CQUFvQkcsVUFBN0IsQ0FBOUMsQ0FESixFQUM2RjtBQUMzRixXQUFPLElBQUlELFNBQUosQ0FBYyx3Q0FBZCxDQUFQO0FBQ0Q7O0FBRUQsTUFBSUYsb0JBQW9CTyxPQUFwQixJQUNGLEVBQUUsc0JBQVNQLG9CQUFvQk8sT0FBN0IsS0FBeUMsc0JBQVNQLG9CQUFvQk8sT0FBN0IsQ0FBM0MsQ0FERixFQUNxRjtBQUNuRixXQUFPLElBQUlMLFNBQUosQ0FBYyxxQ0FBZCxDQUFQO0FBQ0Q7O0FBRUQsTUFBSUYsb0JBQW9CUSxRQUFwQixJQUNGLEVBQUUsc0JBQVNSLG9CQUFvQlEsUUFBN0IsS0FBMEMsc0JBQVNSLG9CQUFvQlEsUUFBN0IsQ0FBNUMsQ0FERixFQUN1RjtBQUNyRixXQUFPLElBQUlOLFNBQUosQ0FBYyxzQ0FBZCxDQUFQO0FBQ0Q7O0FBRUQsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7QUFPQSxTQUFTTywwQkFBVCxDQUFvQ0Msa0JBQXBDLEVBQXdEO0FBQ3RELE1BQUlBLG1CQUFtQkMsTUFBbkIsSUFDRixFQUFFRCxtQkFBbUJDLE1BQW5CLEtBQThCLHFCQUE5QixJQUNBRCxtQkFBbUJDLE1BQW5CLEtBQThCLGVBRDlCLElBRUFELG1CQUFtQkMsTUFBbkIsS0FBOEIsUUFGaEMsQ0FERixFQUlFO0FBQ0EsV0FBTyxJQUFJVCxTQUFKLENBQWMseUVBQWQsQ0FBUDtBQUNEOztBQUVEO0FBQ0EsU0FBTyxLQUFQO0FBQ0Q7O0FBRUQ7Ozs7O0lBSWFVLG1CLFdBQUFBLG1CO0FBQ1g7Ozs7Ozs7Ozs7OztBQVlBLCtCQUFZQyxhQUFaLEVBR1E7QUFBQSxtRkFBSixFQUFJO0FBQUEscUNBRk5DLG1CQUVNO0FBQUEsUUFGTkEsbUJBRU0seUNBRmdCLElBRWhCO0FBQUEscUNBRE5DLDJCQUNNO0FBQUEsUUFETkEsMkJBQ00seUNBRHdCLElBQ3hCOztBQUFBOztBQUNOLFFBQUksQ0FBQyxzQkFBU0YsYUFBVCxDQUFMLEVBQThCO0FBQzVCLFlBQU0sSUFBSVgsU0FBSixDQUFjLDRDQUFkLENBQU47QUFDRDs7QUFFRCxRQUFJWSxzQkFBc0IsSUFBdEIsSUFBOEJBLHNCQUFzQixDQUF4RCxFQUEyRDtBQUN6RCxZQUFNLElBQUlaLFNBQUosQ0FBYyxnREFBZCxDQUFOO0FBQ0Q7O0FBRUQsU0FBS1csYUFBTCxHQUFxQkEsYUFBckI7QUFDQSxTQUFLQyxtQkFBTCxHQUEyQkEsbUJBQTNCO0FBQ0EsU0FBS0MsMkJBQUwsR0FBbUNBLDJCQUFuQztBQUNBLFNBQUtDLFNBQUwsR0FBaUIsRUFBakI7QUFDQSxTQUFLQyxLQUFMLEdBQWFBLGdCQUFNQyxNQUFOLENBQWE7QUFDeEJDLGVBQVM7QUFDUCxzQkFBYztBQURQO0FBRGUsS0FBYixDQUFiOztBQU1BdkIsVUFBTSxjQUFOO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O21DQVVzQztBQUFBOztBQUFBLFVBQXpCd0IsSUFBeUIsdUVBQWxCLGdCQUFrQjs7QUFDcEM7QUFDQSxhQUFPQyxRQUFRQyxPQUFSLEdBQWtCQyxJQUFsQixDQUF1QixZQUFNO0FBQ2xDM0IsY0FBTSwyQkFBTixFQUFtQ3dCLElBQW5DOztBQUVBLGVBQU9JLGVBQUtDLFlBQUwsQ0FBa0IsTUFBS0MsZUFBTCxFQUFsQixDQUFQO0FBQ0QsT0FKTSxDQUFQO0FBS0Q7O0FBRUQ7Ozs7Ozs7Ozs7MEJBT01DLEksRUFBTTtBQUFBOztBQUNWLGFBQU8sS0FBS0YsWUFBTCxHQUNKRixJQURJLENBQ0M7QUFBQSxlQUFVLElBQUlGLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVNLE1BQVYsRUFBcUI7QUFDL0MsaUJBQUtDLE1BQUwsR0FBY0EsTUFBZDtBQUNBQSxpQkFBT0MsRUFBUCxDQUFVLE9BQVYsRUFBbUJGLE1BQW5CO0FBQ0FDLGlCQUFPRSxNQUFQLENBQWNKLElBQWQsRUFBb0I7QUFBQSxtQkFBTUwsUUFBUU8sTUFBUixDQUFOO0FBQUEsV0FBcEI7QUFDQWpDLGdCQUFNLDJCQUFOLEVBQW1DK0IsSUFBbkM7QUFDRCxTQUxlLENBQVY7QUFBQSxPQURELENBQVA7QUFPRDs7QUFFRDs7Ozs7Ozs7MkJBS087QUFBQTs7QUFDTCxhQUFPLElBQUlOLE9BQUosQ0FBWSxVQUFDQyxPQUFELEVBQVVNLE1BQVYsRUFBcUI7QUFDdEMsWUFBSSxPQUFLQyxNQUFULEVBQWlCO0FBQ2YsaUJBQUtBLE1BQUwsQ0FBWUcsS0FBWixDQUFrQixVQUFDQyxLQUFELEVBQVc7QUFDM0IsbUJBQU8sT0FBS0osTUFBWjtBQUNBLGdCQUFJSSxLQUFKLEVBQVc7QUFDVEwscUJBQU9LLEtBQVA7QUFDRCxhQUZELE1BRU87QUFDTFg7QUFDRDtBQUNGLFdBUEQ7QUFRRCxTQVRELE1BU087QUFDTE0saUJBQU8sSUFBSU0sS0FBSixDQUFVLGdFQUFWLENBQVA7QUFDRDtBQUNGLE9BYk0sQ0FBUDtBQWNEOztBQUVEOztBQUVBOzs7Ozs7Ozs7d0NBTW9CO0FBQ2xCLFVBQU1SLGtCQUFrQixLQUFLQSxlQUFMLEVBQXhCO0FBQ0EsYUFBTyxVQUFDUyxHQUFELEVBQU1DLEdBQU4sRUFBV0MsSUFBWCxFQUFvQjtBQUN6QjtBQUNBLFlBQUlGLElBQUlHLElBQVIsRUFBYztBQUNaLGNBQU1MLFFBQVEsSUFBSUMsS0FBSixDQUFVLCtEQUFWLENBQWQ7QUFDQUQsZ0JBQU1NLElBQU4sR0FBYTFDLFdBQVdDLHlCQUF4QjtBQUNBdUMsZUFBS0osS0FBTDtBQUNBO0FBQ0Q7QUFDRFAsd0JBQWdCUyxHQUFoQixFQUFxQkMsR0FBckI7QUFDRCxPQVREO0FBVUQ7O0FBRUQ7Ozs7Ozs7OztzQ0FNa0I7QUFDaEIsYUFBTyxvQ0FBa0IsSUFBbEIsQ0FBUDtBQUNEOztBQUVEOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzJCQTZCT3BDLG1CLEVBQXFCd0MsUSxFQUFVO0FBQ3BDO0FBQ0EsVUFBTUMsb0JBQW9CMUMsMEJBQTBCQyxtQkFBMUIsQ0FBMUI7QUFDQXlDLHdCQUFrQkMsV0FBbEIsR0FBZ0MsUUFBaEM7O0FBRUEsVUFBTVQsUUFBUTNCLG9CQUFvQm1DLGlCQUFwQixDQUFkO0FBQ0EsVUFBSVIsS0FBSixFQUFXO0FBQ1RyQyxjQUFNLG9DQUFOLEVBQTRDcUMsTUFBTVUsT0FBbEQ7QUFDQSxjQUFNVixLQUFOO0FBQ0Q7O0FBRUQsYUFBTyxLQUFLVyxnQkFBTCxDQUFzQkgsaUJBQXRCLEVBQXlDRCxRQUF6QyxDQUFQO0FBQ0Q7O0FBRUQ7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs0QkF5QlF4QyxtQixFQUFxQndDLFEsRUFBVTtBQUNyQztBQUNBLFVBQU05QixxQkFBcUJYLDBCQUEwQkMsbUJBQTFCLENBQTNCO0FBQ0FVLHlCQUFtQmdDLFdBQW5CLEdBQWlDLFNBQWpDOztBQUVBLFVBQU1ULFFBQVEzQixvQkFBb0JJLGtCQUFwQixLQUNaRCwyQkFBMkJDLGtCQUEzQixDQURGO0FBRUEsVUFBSXVCLEtBQUosRUFBVztBQUNUckMsY0FBTSxxQ0FBTixFQUE2Q3FDLE1BQU1VLE9BQW5EO0FBQ0EsY0FBTVYsS0FBTjtBQUNEOztBQUVELGFBQU8sS0FBS1csZ0JBQUwsQ0FBc0JsQyxrQkFBdEIsRUFBMEM4QixRQUExQyxDQUFQO0FBQ0Q7O0FBRUQ7O0FBRUE7Ozs7Ozs7Ozs7Ozs7NkJBVVNLLE8sRUFBUztBQUFBOztBQUNoQixVQUFNTCxXQUFXLEtBQUtNLGFBQUwsQ0FBbUJELE9BQW5CLENBQWpCO0FBQ0EsVUFBSSxDQUFDTCxRQUFMLEVBQWU7QUFDYjVDLGNBQU0sbUNBQU47QUFDQSxlQUFPbUQsU0FBUDtBQUNEO0FBQ0RuRCxZQUFNLHdCQUFOOztBQU5nQixxQ0FPTzRDLFFBUFA7QUFBQSxVQU9QUSxVQVBPOztBQVNoQjs7O0FBQ0EsVUFBSUMsZ0JBQUo7QUFDQSxVQUFJSixRQUFRSyxZQUFaLEVBQTBCO0FBQ3hCRCxrQkFBVSxpQkFBQ04sT0FBRCxFQUFhO0FBQ3JCLGNBQUksT0FBT0EsUUFBUXBCLElBQWYsS0FBd0IsVUFBNUIsRUFBd0M7QUFDdEMsa0JBQU0sSUFBSXJCLFNBQUosQ0FBYyxxREFBZCxDQUFOO0FBQ0Q7QUFDRE4sZ0JBQU0sd0JBQU47QUFDQSxpQkFBTyxPQUFLcUIsS0FBTCxDQUFXa0MsSUFBWCxDQUFnQk4sUUFBUUssWUFBeEIsRUFBc0NQLE9BQXRDLENBQVA7QUFDRCxTQU5EO0FBT0Q7O0FBRUQsVUFBSVMsdUJBQUo7QUFDQSxVQUFJO0FBQ0ZBLHlCQUFpQkosV0FBV0ssSUFBWCxDQUFnQixJQUFoQixFQUFzQlIsT0FBdEIsRUFBK0JJLE9BQS9CLENBQWpCO0FBQ0QsT0FGRCxDQUVFLE9BQU9oQixLQUFQLEVBQWM7QUFDZHJDLGNBQU0sb0JBQU4sRUFBNEJxQyxLQUE1QjtBQUNBLGVBQU9aLFFBQVFDLE9BQVIsQ0FBZ0IsRUFBRWdDLFFBQVEsR0FBVixFQUFoQixDQUFQO0FBQ0Q7O0FBRUQsVUFBSUYsY0FBSixFQUFvQjtBQUNsQixlQUFPLDBCQUFlLEtBQUt0QyxtQkFBcEIsRUFBeUNzQyxjQUF6QyxFQUNKN0IsSUFESSxDQUNDO0FBQUEsaUJBQVksRUFBRStCLFFBQVEsR0FBVixFQUFlQyxPQUFmLEVBQVo7QUFBQSxTQURELEVBRUpDLEtBRkksQ0FFRSxVQUFDdkIsS0FBRCxFQUFXO0FBQ2hCLGNBQUlBLE1BQU1NLElBQU4sS0FBZWtCLGlCQUFlQyxlQUFsQyxFQUFtRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFJLENBQUMsT0FBSzNDLDJCQUFOLElBQXFDLENBQUNrQyxPQUF0QyxJQUFpREosUUFBUWMsSUFBUixLQUFpQixtQkFBdEUsRUFBMkY7QUFDekYvRCxvQkFBTSxrRUFBTjtBQUNBLHFCQUFPd0QsZUFDSjdCLElBREksQ0FDQztBQUFBLHVCQUFZLEVBQUUrQixRQUFRLEdBQVYsRUFBZUMsT0FBZixFQUFaO0FBQUEsZUFERCxFQUVKQyxLQUZJLENBRUU7QUFBQSx1QkFBTyxFQUFFRixRQUFRLEdBQVYsRUFBUDtBQUFBLGVBRkYsQ0FBUDtBQUdEOztBQUVEO0FBQ0E7QUFDQUYsMkJBQWU3QixJQUFmLENBQW9CMEIsT0FBcEIsRUFBNkJPLEtBQTdCLENBQW1DLFVBQUNJLGFBQUQsRUFBbUI7QUFDcEQ7QUFDQWhFLG9CQUFNLHNFQUFOO0FBQ0Esb0JBQU1nRSxhQUFOO0FBQ0QsYUFKRDtBQUtBLG1CQUFPLEVBQUVOLFFBQVEsR0FBVixFQUFQO0FBQ0Q7O0FBRUQsaUJBQU8sRUFBRUEsUUFBUSxHQUFWLEVBQVA7QUFDRCxTQTFCSSxDQUFQO0FBMkJEOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBT2pDLFFBQVFDLE9BQVIsQ0FBZ0IsRUFBRWdDLFFBQVEsR0FBVixFQUFoQixDQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztxQ0FHaUJPLFcsRUFBYXJCLFEsRUFBVTtBQUN0QztBQUNBLFVBQUksQ0FBQyxzQkFBV0EsUUFBWCxDQUFMLEVBQTJCO0FBQ3pCNUMsY0FBTSxzREFBTjtBQUNBLGNBQU0sSUFBSU0sU0FBSixDQUFjLDZCQUFkLENBQU47QUFDRDs7QUFFRCxXQUFLYyxTQUFMLENBQWU4QyxJQUFmLENBQW9CLENBQUNELFdBQUQsRUFBY3JCLFFBQWQsQ0FBcEI7O0FBRUEsYUFBTyxJQUFQO0FBQ0Q7O0FBRUQ7Ozs7OztrQ0FHY0ssTyxFQUFTO0FBQ3JCLGFBQU8sS0FBSzdCLFNBQUwsQ0FBZStDLElBQWYsQ0FBb0IsaUJBQW1CO0FBQUE7QUFBQSxZQUFqQkYsV0FBaUI7O0FBQzVDO0FBQ0EsWUFBSUEsWUFBWTFELFVBQWhCLEVBQTRCO0FBQzFCLGNBQUksc0JBQVMwRCxZQUFZMUQsVUFBckIsS0FBb0MwQyxRQUFRbUIsV0FBUixLQUF3QkgsWUFBWTFELFVBQTVFLEVBQXdGO0FBQ3RGLG1CQUFPLEtBQVA7QUFDRDtBQUNELGNBQUksc0JBQVMwRCxZQUFZMUQsVUFBckIsS0FBb0MsQ0FBQzBELFlBQVkxRCxVQUFaLENBQXVCOEQsSUFBdkIsQ0FBNEJwQixRQUFRbUIsV0FBcEMsQ0FBekMsRUFBMkY7QUFDekYsbUJBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxZQUFJSCxZQUFZbkIsV0FBWixLQUE0QixRQUFoQyxFQUEwQztBQUN4QztBQUNBLGNBQUksRUFBRUcsUUFBUXFCLE9BQVIsSUFBbUJyQixRQUFRc0IsVUFBM0IsSUFBeUN0QixRQUFRRixPQUFuRCxDQUFKLEVBQWlFO0FBQy9ELG1CQUFPLEtBQVA7QUFDRDs7QUFFRDtBQUNBO0FBQ0EsY0FBTXlCLFNBQVN2QixRQUFRcUIsT0FBUixHQUFrQnJCLFFBQVFxQixPQUFSLENBQWdCLENBQWhCLENBQWxCLEdBQXVDLEVBQXREOztBQUVBO0FBQ0EsY0FBSUwsWUFBWXRELE9BQWhCLEVBQXlCO0FBQ3ZCLGdCQUFJLHNCQUFTc0QsWUFBWXRELE9BQXJCLEtBQWlDNkQsT0FBT0MsUUFBUCxLQUFvQlIsWUFBWXRELE9BQXJFLEVBQThFO0FBQzVFLHFCQUFPLEtBQVA7QUFDRDtBQUNELGdCQUFJLHNCQUFTc0QsWUFBWXRELE9BQXJCLEtBQWlDLENBQUNzRCxZQUFZdEQsT0FBWixDQUFvQjBELElBQXBCLENBQXlCRyxPQUFPQyxRQUFoQyxDQUF0QyxFQUFpRjtBQUMvRSxxQkFBTyxLQUFQO0FBQ0Q7QUFDRjs7QUFFRDtBQUNBLGNBQUlSLFlBQVlyRCxRQUFoQixFQUEwQjtBQUN4QixnQkFBSSxzQkFBU3FELFlBQVlyRCxRQUFyQixLQUFrQzRELE9BQU9FLFNBQVAsS0FBcUJULFlBQVlyRCxRQUF2RSxFQUFpRjtBQUMvRSxxQkFBTyxLQUFQO0FBQ0Q7QUFDRCxnQkFBSSxzQkFBU3FELFlBQVlyRCxRQUFyQixLQUFrQyxDQUFDcUQsWUFBWXJELFFBQVosQ0FBcUJ5RCxJQUFyQixDQUEwQkcsT0FBT0UsU0FBakMsQ0FBdkMsRUFBb0Y7QUFDbEYscUJBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNWCxPQUFPUyxPQUFPVCxJQUFQLElBQWVkLFFBQVFjLElBQXZCLElBQWdDUyxPQUFPRyxnQkFBUCxJQUEyQixRQUF4RTtBQUNBLGNBQUksQ0FBQ1osSUFBTCxFQUFXO0FBQ1QvRCxrQkFBTSxvQ0FBTjtBQUNEO0FBQ0Q7QUFDQSxjQUFJaUUsWUFBWUYsSUFBWixJQUFvQkUsWUFBWUYsSUFBWixLQUFxQkEsSUFBN0MsRUFBbUQ7QUFDakQsbUJBQU8sS0FBUDtBQUNEOztBQUVEO0FBQ0EsY0FBSSxZQUFZRSxXQUFaLEtBRUNBLFlBQVlXLE1BQVosSUFBc0IsQ0FBQzNCLFFBQVE0QixhQUFoQyxJQUNDLENBQUNaLFlBQVlXLE1BQWIsSUFBdUIzQixRQUFRNEIsYUFIaEMsQ0FBSixFQUtFO0FBQ0EsbUJBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQsWUFBSVosWUFBWW5CLFdBQVosS0FBNEIsU0FBaEMsRUFBMkM7QUFDekM7QUFDQTtBQUNBLGNBQUksRUFBRSxVQUFVRyxPQUFWLElBQXNCQSxRQUFRYyxJQUFSLElBQWdCZCxRQUFRYyxJQUFSLEtBQWlCLGtCQUF6RCxDQUFKLEVBQW1GO0FBQ2pGLG1CQUFPLEtBQVA7QUFDRDs7QUFFRDtBQUNBLGNBQUlFLFlBQVl0RCxPQUFoQixFQUF5QjtBQUN2QixnQkFBSSxzQkFBU3NELFlBQVl0RCxPQUFyQixLQUFpQ3NDLFFBQVF3QixRQUFSLEtBQXFCUixZQUFZdEQsT0FBdEUsRUFBK0U7QUFDN0UscUJBQU8sS0FBUDtBQUNEO0FBQ0QsZ0JBQUksc0JBQVNzRCxZQUFZdEQsT0FBckIsS0FBaUMsQ0FBQ3NELFlBQVl0RCxPQUFaLENBQW9CMEQsSUFBcEIsQ0FBeUJwQixRQUFRd0IsUUFBakMsQ0FBdEMsRUFBa0Y7QUFDaEYscUJBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUQ7QUFDQSxjQUFJUixZQUFZckQsUUFBaEIsRUFBMEI7QUFDeEIsZ0JBQUksc0JBQVNxRCxZQUFZckQsUUFBckIsS0FBa0NxQyxRQUFReUIsU0FBUixLQUFzQlQsWUFBWXJELFFBQXhFLEVBQWtGO0FBQ2hGLHFCQUFPLEtBQVA7QUFDRDtBQUNELGdCQUFJLHNCQUFTcUQsWUFBWXJELFFBQXJCLEtBQWtDLENBQUNxRCxZQUFZckQsUUFBWixDQUFxQnlELElBQXJCLENBQTBCcEIsUUFBUXlCLFNBQWxDLENBQXZDLEVBQXFGO0FBQ25GLHFCQUFPLEtBQVA7QUFDRDtBQUNGOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFJVCxZQUFZbEQsTUFBaEIsRUFBd0I7QUFDdEIsZ0JBQUlrRCxZQUFZbEQsTUFBWixLQUF1QixxQkFBdkIsSUFBZ0RrQyxRQUFRYyxJQUFSLEtBQWlCLHFCQUFyRSxFQUE0RjtBQUMxRixxQkFBTyxLQUFQO0FBQ0Q7QUFDRCxnQkFBSUUsWUFBWWxELE1BQVosS0FBdUIsZUFBdkIsSUFBMENrQyxRQUFRYyxJQUFSLEtBQWlCLGtCQUEvRCxFQUFtRjtBQUNqRixxQkFBTyxLQUFQO0FBQ0Q7QUFDRCxnQkFBSUUsWUFBWWxELE1BQVosS0FBdUIsUUFBdkIsSUFBbUNrQyxRQUFRYyxJQUFSLEtBQWlCLG1CQUF4RCxFQUE2RTtBQUMzRSxxQkFBTyxLQUFQO0FBQ0Q7QUFDRjtBQUNGOztBQUVEO0FBQ0EsZUFBTyxJQUFQO0FBQ0QsT0FqSE0sQ0FBUDtBQWtIRDs7Ozs7O0FBR0g7Ozs7O2tCQUdlL0MsbUI7O0FBRWY7Ozs7O0FBS0E7Ozs7O0FBS0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJBOzs7Ozs7Ozs7Ozs7OztBQWNBIiwiZmlsZSI6ImFkYXB0ZXIuanMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBtb2R1bGUgYWRhcHRlclxuICovXG5cbmltcG9ydCBodHRwIGZyb20gJ2h0dHAnO1xuaW1wb3J0IGF4aW9zIGZyb20gJ2F4aW9zJztcbmltcG9ydCBpc1N0cmluZyBmcm9tICdsb2Rhc2guaXNzdHJpbmcnO1xuaW1wb3J0IGlzUGxhaW5PYmplY3QgZnJvbSAnbG9kYXNoLmlzcGxhaW5vYmplY3QnO1xuaW1wb3J0IGlzUmVnRXhwIGZyb20gJ2xvZGFzaC5pc3JlZ2V4cCc7XG5pbXBvcnQgaXNGdW5jdGlvbiBmcm9tICdsb2Rhc2guaXNmdW5jdGlvbic7XG5pbXBvcnQgZGVidWdGYWN0b3J5IGZyb20gJ2RlYnVnJztcbmltcG9ydCB7IGNyZWF0ZUhUVFBIYW5kbGVyIH0gZnJvbSAnLi9odHRwLWhhbmRsZXInO1xuaW1wb3J0IHsgcGFja2FnZUlkZW50aWZpZXIsIHByb21pc2VUaW1lb3V0LCBlcnJvckNvZGVzIGFzIHV0aWxFcnJvckNvZGVzIH0gZnJvbSAnLi91dGlsJztcblxuY29uc3QgZGVidWcgPSBkZWJ1Z0ZhY3RvcnkoJ0BzbGFjay9pbnRlcmFjdGl2ZS1tZXNzYWdlczphZGFwdGVyJyk7XG5cbmV4cG9ydCBjb25zdCBlcnJvckNvZGVzID0ge1xuICBCT0RZX1BBUlNFUl9OT1RfUEVSTUlUVEVEOiAnU0xBQ0tBREFQVEVSX0JPRFlfUEFSU0VSX05PVF9QRVJNSVRURURfRkFJTFVSRScsXG59O1xuXG4vKipcbiAqIFRyYW5zZm9ybXMgdmFyaW91cyBmb3JtcyBvZiBtYXRjaGluZyBjb25zdHJhaW50cyB0byBhIHNpbmdsZSBzdGFuZGFyZCBvYmplY3Qgc2hhcGVcbiAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cHxPYmplY3R9IG1hdGNoaW5nQ29uc3RyYWludHMgLSB0aGUgdmFyaW91cyBmb3JtcyBvZiBtYXRjaGluZyBjb25zdHJhaW50c1xuICogYWNjZXB0ZWRcbiAqIEByZXR1cm5zIHtPYmplY3R9IC0gYW4gb2JqZWN0IHdoZXJlIGVhY2ggbWF0Y2hpbmcgY29uc3RyYWludCBpcyBhIHByb3BlcnR5XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBmb3JtYXRNYXRjaGluZ0NvbnN0cmFpbnRzKG1hdGNoaW5nQ29uc3RyYWludHMpIHtcbiAgbGV0IHJldCA9IHt9O1xuICBpZiAodHlwZW9mIG1hdGNoaW5nQ29uc3RyYWludHMgPT09ICd1bmRlZmluZWQnIHx8IG1hdGNoaW5nQ29uc3RyYWludHMgPT09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDb25zdHJhaW50cyBjYW5ub3QgYmUgdW5kZWZpbmVkIG9yIG51bGwnKTtcbiAgfVxuICBpZiAoIWlzUGxhaW5PYmplY3QobWF0Y2hpbmdDb25zdHJhaW50cykpIHtcbiAgICByZXQuY2FsbGJhY2tJZCA9IG1hdGNoaW5nQ29uc3RyYWludHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0ID0gT2JqZWN0LmFzc2lnbih7fSwgbWF0Y2hpbmdDb25zdHJhaW50cyk7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgZ2VuZXJhbCBwcm9wZXJ0aWVzIG9mIGEgbWF0Y2hpbmcgY29uc3RyYWludHMgb2JqZWN0XG4gKiBAcGFyYW0ge09iamVjdH0gbWF0Y2hpbmdDb25zdHJhaW50cyAtIG9iamVjdCBkZXNjcmliaW5nIHRoZSBjb25zdHJhaW50cyBvbiBhIGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RXJyb3J8ZmFsc2V9IC0gYSBmYWxzZSB2YWx1ZSByZXByZXNlbnRzIHN1Y2Nlc3NmdWwgdmFsaWRhdGlvbiwgb3RoZXJ3aXNlIGFuIGVycm9yIHRvXG4gKiBkZXNjcmliZSB3aHkgdmFsaWRhdGlvbiBmYWlsZWQuXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUNvbnN0cmFpbnRzKG1hdGNoaW5nQ29uc3RyYWludHMpIHtcbiAgaWYgKG1hdGNoaW5nQ29uc3RyYWludHMuY2FsbGJhY2tJZCAmJlxuICAgICAgIShpc1N0cmluZyhtYXRjaGluZ0NvbnN0cmFpbnRzLmNhbGxiYWNrSWQpIHx8IGlzUmVnRXhwKG1hdGNoaW5nQ29uc3RyYWludHMuY2FsbGJhY2tJZCkpKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0NhbGxiYWNrIElEIG11c3QgYmUgYSBzdHJpbmcgb3IgUmVnRXhwJyk7XG4gIH1cblxuICBpZiAobWF0Y2hpbmdDb25zdHJhaW50cy5ibG9ja0lkICYmXG4gICAgIShpc1N0cmluZyhtYXRjaGluZ0NvbnN0cmFpbnRzLmJsb2NrSWQpIHx8IGlzUmVnRXhwKG1hdGNoaW5nQ29uc3RyYWludHMuYmxvY2tJZCkpKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0Jsb2NrIElEIG11c3QgYmUgYSBzdHJpbmcgb3IgUmVnRXhwJyk7XG4gIH1cblxuICBpZiAobWF0Y2hpbmdDb25zdHJhaW50cy5hY3Rpb25JZCAmJlxuICAgICEoaXNTdHJpbmcobWF0Y2hpbmdDb25zdHJhaW50cy5hY3Rpb25JZCkgfHwgaXNSZWdFeHAobWF0Y2hpbmdDb25zdHJhaW50cy5hY3Rpb25JZCkpKSB7XG4gICAgcmV0dXJuIG5ldyBUeXBlRXJyb3IoJ0FjdGlvbiBJRCBtdXN0IGJlIGEgc3RyaW5nIG9yIFJlZ0V4cCcpO1xuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIFZhbGlkYXRlcyBwcm9wZXJ0aWVzIG9mIGEgbWF0Y2hpbmcgY29uc3RyYWludHMgb2JqZWN0IHNwZWNpZmljIHRvIHJlZ2lzdGVyaW5nIGFuIG9wdGlvbnMgcmVxdWVzdFxuICogQHBhcmFtIHtPYmplY3R9IG1hdGNoaW5nQ29uc3RyYWludHMgLSBvYmplY3QgZGVzY3JpYmluZyB0aGUgY29uc3RyYWludHMgb24gYSBjYWxsYmFja1xuICogQHJldHVybnMge0Vycm9yfGZhbHNlfSAtIGEgZmFsc2UgdmFsdWUgcmVwcmVzZW50cyBzdWNjZXNzZnVsIHZhbGlkYXRpb24sIG90aGVyd2lzZSBhbiBlcnJvciB0b1xuICogZGVzY3JpYmUgd2h5IHZhbGlkYXRpb24gZmFpbGVkLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVPcHRpb25zQ29uc3RyYWludHMob3B0aW9uc0NvbnN0cmFpbnRzKSB7XG4gIGlmIChvcHRpb25zQ29uc3RyYWludHMud2l0aGluICYmXG4gICAgIShvcHRpb25zQ29uc3RyYWludHMud2l0aGluID09PSAnaW50ZXJhY3RpdmVfbWVzc2FnZScgfHxcbiAgICAgIG9wdGlvbnNDb25zdHJhaW50cy53aXRoaW4gPT09ICdibG9ja19hY3Rpb25zJyB8fFxuICAgICAgb3B0aW9uc0NvbnN0cmFpbnRzLndpdGhpbiA9PT0gJ2RpYWxvZycpXG4gICkge1xuICAgIHJldHVybiBuZXcgVHlwZUVycm9yKCdXaXRoaW4gbXVzdCBiZSBcXCdibG9ja19hY3Rpb25zXFwnLCBcXCdpbnRlcmFjdGl2ZV9tZXNzYWdlXFwnIG9yIFxcJ2RpYWxvZ1xcJycpO1xuICB9XG5cbiAgLy8gV2UgZG9uJ3QgbmVlZCB0byB2YWxpZGF0ZSB1bmZ1cmwsIHdlJ2xsIGp1c3QgY29vZXJjZSBpdCB0byBhIGJvb2xlYW5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vKipcbiAqIEFuIGFkYXB0ZXIgZm9yIFNsYWNrJ3MgaW50ZXJhY3RpdmUgbWVzc2FnZSBjb21wb25lbnRzIHN1Y2ggYXMgYnV0dG9ucywgbWVudXMsIGFuZCBkaWFsb2dzLlxuICogQHR5cGljYWxuYW1lIHNsYWNrSW50ZXJhY3Rpb25zXG4gKi9cbmV4cG9ydCBjbGFzcyBTbGFja01lc3NhZ2VBZGFwdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG1lc3NhZ2UgYWRhcHRlci5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNpZ25pbmdTZWNyZXQgLSBTbGFjayBhcHAgc2lnbmluZyBzZWNyZXQgdXNlZCB0byBhdXRoZW50aWNhdGUgcmVxdWVzdFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zeW5jUmVzcG9uc2VUaW1lb3V0PTI1MDBdIC0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZVxuICAgKiBmbHVzaGluZyBhIHN5bmNyaG9ub3VzIHJlc3BvbnNlIHRvIGFuIGluY29taW5nIHJlcXVlc3QgYW5kIGZhbGxpbmcgYmFjayB0byBhbiBhc3luY2hyb25vdXNcbiAgICogcmVzcG9uc2UuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGF0ZVJlc3BvbnNlRmFsbGJhY2tFbmFibGVkPXRydWVdIC0gd2hldGhlciBvciBub3QgcHJvbWlzZXMgdGhhdFxuICAgKiByZXNvbHZlIGFmdGVyIHRoZSBzeW5jUmVzcG9uc2VUaW1lb3V0IGNhbiBmYWxsYmFjayB0byBhIHJlcXVlc3QgZm9yIHRoZSByZXNwb25zZV91cmwuIHRoaXMgb25seVxuICAgKiB3b3JrcyBpbiBjYXNlcyB3aGVyZSB0aGUgc2VtYW50aWMgbWVhbmluZyBvZiB0aGUgcmVzcG9uc2UgYW5kIHRoZSByZXNwb25zZV91cmwgYXJlIHRoZSBzYW1lLlxuICAgKi9cbiAgY29uc3RydWN0b3Ioc2lnbmluZ1NlY3JldCwge1xuICAgIHN5bmNSZXNwb25zZVRpbWVvdXQgPSAyNTAwLFxuICAgIGxhdGVSZXNwb25zZUZhbGxiYWNrRW5hYmxlZCA9IHRydWUsXG4gIH0gPSB7fSkge1xuICAgIGlmICghaXNTdHJpbmcoc2lnbmluZ1NlY3JldCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1NsYWNrTWVzc2FnZUFkYXB0ZXIgbmVlZHMgYSBzaWduaW5nIHNlY3JldCcpO1xuICAgIH1cblxuICAgIGlmIChzeW5jUmVzcG9uc2VUaW1lb3V0ID4gMzAwMCB8fCBzeW5jUmVzcG9uc2VUaW1lb3V0IDwgMSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignc3luY1Jlc3BvbnNlVGltZW91dCBtdXN0IGJlIGJldHdlZW4gMSBhbmQgMzAwMCcpO1xuICAgIH1cblxuICAgIHRoaXMuc2lnbmluZ1NlY3JldCA9IHNpZ25pbmdTZWNyZXQ7XG4gICAgdGhpcy5zeW5jUmVzcG9uc2VUaW1lb3V0ID0gc3luY1Jlc3BvbnNlVGltZW91dDtcbiAgICB0aGlzLmxhdGVSZXNwb25zZUZhbGxiYWNrRW5hYmxlZCA9IGxhdGVSZXNwb25zZUZhbGxiYWNrRW5hYmxlZDtcbiAgICB0aGlzLmNhbGxiYWNrcyA9IFtdO1xuICAgIHRoaXMuYXhpb3MgPSBheGlvcy5jcmVhdGUoe1xuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnVXNlci1BZ2VudCc6IHBhY2thZ2VJZGVudGlmaWVyKCksXG4gICAgICB9LFxuICAgIH0pO1xuXG4gICAgZGVidWcoJ2luc3RhbnRpYXRlZCcpO1xuICB9XG5cbiAgLyogSW50ZXJmYWNlIGZvciB1c2luZyB0aGUgYnVpbHQtaW4gc2VydmVyICovXG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhIHNlcnZlciB0aGF0IGRpc3BhdGNoZXMgU2xhY2sncyBpbnRlcmFjdGl2ZSBtZXNzYWdlIGFjdGlvbnMgYW5kIG1lbnUgcmVxdWVzdHMgdG8gdGhpc1xuICAgKiBtZXNzYWdlIGFkYXB0ZXIgaW5zdGFuY2UuIFVzZSB0aGlzIG1ldGhvZCBpZiB5b3VyIGFwcGxpY2F0aW9uIHdpbGwgaGFuZGxlIHN0YXJ0aW5nIHRoZSBzZXJ2ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcGF0aD0vc2xhY2svYWN0aW9uc10gLSBUaGUgcGF0aCBwb3J0aW9uIG9mIHRoZSBVUkwgd2hlcmUgdGhlIHNlcnZlciB3aWxsXG4gICAqIGxpc3RlbiBmb3IgcmVxdWVzdHMgZnJvbSBTbGFjaydzIGludGVyYWN0aXZlIG1lc3NhZ2VzLlxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTxOb2RlSHR0cFNlcnZlcj59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gYW4gaW5zdGFuY2Ugb2YgaHR0cC5TZXJ2ZXIgYW5kXG4gICAqIHdpbGwgZGlzcGF0Y2ggaW50ZXJhY3RpdmUgbWVzc2FnZSBhY3Rpb25zIGFuZCBvcHRpb25zIHJlcXVlc3RzIHRvIHRoaXMgbWVzc2FnZSBhZGFwdGVyXG4gICAqIGluc3RhbmNlLiBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvaHR0cC5odG1sI2h0dHBfY2xhc3NfaHR0cF9zZXJ2ZXJcbiAgICovXG4gIGNyZWF0ZVNlcnZlcihwYXRoID0gJy9zbGFjay9hY3Rpb25zJykge1xuICAgIC8vIFRPRE86IG1vcmUgb3B0aW9ucyAobGlrZSBodHRwcylcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICBkZWJ1Zygnc2VydmVyIGNyZWF0ZWQgLSBwYXRoOiAlcycsIHBhdGgpO1xuXG4gICAgICByZXR1cm4gaHR0cC5jcmVhdGVTZXJ2ZXIodGhpcy5yZXF1ZXN0TGlzdGVuZXIoKSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogU3RhcnQgYSBidWlsdC1pbiBzZXJ2ZXIgdGhhdCBkaXNwYXRjaGVzIFNsYWNrJ3MgaW50ZXJhY3RpdmUgbWVzc2FnZSBhY3Rpb25zIGFuZCBtZW51IHJlcXVlc3RzXG4gICAqIHRvIHRoaXMgbWVzc2FnZSBhZGFwdGVyIGludGVyZmFjZS5cbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJ9IHBvcnRcbiAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59IC0gQSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgb25jZSB0aGUgc2VydmVyIGlzIHJlYWR5XG4gICAqL1xuICBzdGFydChwb3J0KSB7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlU2VydmVyKClcbiAgICAgIC50aGVuKHNlcnZlciA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICBzZXJ2ZXIub24oJ2Vycm9yJywgcmVqZWN0KTtcbiAgICAgICAgc2VydmVyLmxpc3Rlbihwb3J0LCAoKSA9PiByZXNvbHZlKHNlcnZlcikpO1xuICAgICAgICBkZWJ1Zygnc2VydmVyIHN0YXJ0ZWQgLSBwb3J0OiAlcycsIHBvcnQpO1xuICAgICAgfSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0b3AgdGhlIHByZXZpb3VzbHkgc3RhcnRlZCBidWlsdC1pbiBzZXJ2ZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fSAtIEEgcHJvbWlzZSB0aGF0IHJlc29sdmVzIG9uY2UgdGhlIHNlcnZlciBpcyBjbGVhbmVkIHVwLlxuICAgKi9cbiAgc3RvcCgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKHRoaXMuc2VydmVyKSB7XG4gICAgICAgIHRoaXMuc2VydmVyLmNsb3NlKChlcnJvcikgPT4ge1xuICAgICAgICAgIGRlbGV0ZSB0aGlzLnNlcnZlcjtcbiAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcignU2xhY2tNZXNzYWdlQWRhcHRlciBjYW5ub3Qgc3RvcCB3aGVuIGl0IGRpZCBub3Qgc3RhcnQgYSBzZXJ2ZXInKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKiBJbnRlcmZhY2UgZm9yIGJyaW5naW5nIHlvdXIgb3duIHNlcnZlciAqL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBtaWRkbGV3YXJlIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gaW50ZWdyYXRlIHdpdGggdGhlIGBleHByZXNzYCB3ZWIgZnJhbWV3b3JrXG4gICAqIGluIG9yZGVyIGZvciBpbmNvbWluZyByZXF1ZXN0cyB0byBiZSBkaXNwYXRjaGVkIHRvIHRoaXMgbWVzc2FnZSBhZGFwdGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7RXhwcmVzc01pZGRsZXdhcmVGdW5jfSAtIEEgbWlkZGxld2FyZSBmdW5jdGlvbiBodHRwOi8vZXhwcmVzc2pzLmNvbS9lbi9ndWlkZS91c2luZy1taWRkbGV3YXJlLmh0bWxcbiAgICovXG4gIGV4cHJlc3NNaWRkbGV3YXJlKCkge1xuICAgIGNvbnN0IHJlcXVlc3RMaXN0ZW5lciA9IHRoaXMucmVxdWVzdExpc3RlbmVyKCk7XG4gICAgcmV0dXJuIChyZXEsIHJlcywgbmV4dCkgPT4ge1xuICAgICAgLy8gSWYgcGFyc2VyIGlzIGJlaW5nIHVzZWQsIHdlIGNhbid0IHZlcmlmeSByZXF1ZXN0IHNpZ25hdHVyZVxuICAgICAgaWYgKHJlcS5ib2R5KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKCdQYXJzaW5nIHJlcXVlc3QgYm9keSBwcm9oaWJpdHMgcmVxdWVzdCBzaWduYXR1cmUgdmVyaWZpY2F0aW9uJyk7XG4gICAgICAgIGVycm9yLmNvZGUgPSBlcnJvckNvZGVzLkJPRFlfUEFSU0VSX05PVF9QRVJNSVRURUQ7XG4gICAgICAgIG5leHQoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXF1ZXN0TGlzdGVuZXIocmVxLCByZXMpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGEgcmVxdWVzdCBsaXN0ZW5lciBmdW5jdGlvbiB0aGF0IGhhbmRsZXMgSFRUUCByZXF1ZXN0cywgdmVyaWZpZXMgcmVxdWVzdHNcbiAgICogYW5kIGRpc3BhdGNoZXMgcmVzcG9uc2VzXG4gICAqXG4gICAqIEByZXR1cm5zIHtzbGFja1JlcXVlc3RMaXN0ZW5lcn1cbiAgICovXG4gIHJlcXVlc3RMaXN0ZW5lcigpIHtcbiAgICByZXR1cm4gY3JlYXRlSFRUUEhhbmRsZXIodGhpcyk7XG4gIH1cblxuICAvKiBJbnRlcmZhY2UgZm9yIGFkZGluZyBoYW5kbGVycyAqL1xuXG4gIC8qIGVzbGludC1kaXNhYmxlIG1heC1sZW4gKi9cbiAgLyoqXG4gICAqIEFkZCBhIGhhbmRsZXIgZm9yIGFuIGludGVyYWN0aXZlIG1lc3NhZ2UgYWN0aW9uLlxuICAgKlxuICAgKiBVc3VhbGx5IHRoZXJlJ3Mgbm8gbmVlZCB0byBiZSBjb25jZXJuZWQgd2l0aCBfaG93XyBhIG1lc3NhZ2UgaXMgc2VudCB0byBTbGFjaywgYnV0IHRoZVxuICAgKiBmb2xsb3dpbmcgdGFibGUgZGVzY3JpYmVzIGl0IGZ1bGx5LlxuICAgKlxuICAgKiAqKkFjdGlvbioqfCoqUmV0dXJuIGBvYmplY3RgKip8KipSZXR1cm4gYFByb21pc2U8b2JqZWN0PmAqKnwqKlJldHVybiBgdW5kZWZpbmVkYCoqfCoqQ2FsbCBgcmVzcG9uZChtZXNzYWdlKWAqKnwqKk5vdGVzKipcbiAgICogOi0tLS0tOnw6LS0tLS06fDotLS0tLTp8Oi0tLS0tOnw6LS0tLS06fDotLS0tLTpcbiAgICogKipCdXR0b24gUHJlc3MqKnwgTWVzc2FnZSBpbiByZXNwb25zZSB8IFdoZW4gcmVzb2x2ZWQgYmVmb3JlIGBzeW5jUmVzcG9zZVRpbWVvdXRgIG9yIGBsYXRlUmVzcG9uc2VGYWxsYmFja0VuYWJsZWQ6IGZhbHNlYCwgbWVzc2FnZSBpbiByZXNwb25zZTxiciAvPldoZW4gcmVzb2x2ZWQgYWZ0ZXIgYHN5bmNSZXNwb25zZVRpbWVvdXRgIGFuZCBgbGF0ZVJlc3BvbnNlRmFsbGJhY2tFbmFibGVkOiB0cnVlYCwgbWVzc2FnZSBpbiByZXF1ZXN0IHRvIGByZXNwb25zZV91cmxgIHwgRW1wdHkgcmVzcG9uc2UgfCBNZXNzYWdlIGluIHJlcXVlc3QgdG8gYHJlc3BvbnNlX3VybGAgfCBDcmVhdGUgYSBuZXcgbWVzc2FnZSBpbnN0ZWFkIG9mIHJlcGxhY2luZyB1c2luZyBgcmVwbGFjZV9vcmlnaW5hbDogZmFsc2VgXG4gICAqICoqTWVudSBTZWxlY3Rpb24qKnwgTWVzc2FnZSBpbiByZXNwb25zZSB8IFdoZW4gcmVzb2x2ZWQgYmVmb3JlIGBzeW5jUmVzcG9zZVRpbWVvdXRgIG9yIGBsYXRlUmVzcG9uc2VGYWxsYmFja0VuYWJsZWQ6IGZhbHNlYCwgbWVzc2FnZSBpbiByZXNwb25zZTxiciAvPldoZW4gcmVzb2x2ZWQgYWZ0ZXIgYHN5bmNSZXNwb25zZVRpbWVvdXRgIGFuZCBgbGF0ZVJlc3BvbnNlRmFsbGJhY2tFbmFibGVkOiB0cnVlYCwgbWVzc2FnZSBpbiByZXF1ZXN0IHRvIGByZXNwb25zZV91cmxgIHwgRW1wdHkgcmVzcG9uc2UgfCBNZXNzYWdlIGluIHJlcXVlc3QgdG8gYHJlc3BvbnNlX3VybGAgfCBDcmVhdGUgYSBuZXcgbWVzc2FnZSBpbnN0ZWFkIG9mIHJlcGxhY2luZyB1c2luZyBgcmVwbGFjZV9vcmlnaW5hbDogZmFsc2VgXG4gICAqICoqTWVzc2FnZSBBY3Rpb24qKiB8IE1lc3NhZ2UgaW4gcmVzcG9uc2UgfCBXaGVuIHJlc29sdmVkIGJlZm9yZSBgc3luY1Jlc3Bvc2VUaW1lb3V0YCBvciBgbGF0ZVJlc3BvbnNlRmFsbGJhY2tFbmFibGVkOiBmYWxzZWAsIG1lc3NhZ2UgaW4gcmVzcG9uc2U8YnIgLz5XaGVuIHJlc29sdmVkIGFmdGVyIGBzeW5jUmVzcG9uc2VUaW1lb3V0YCBhbmQgYGxhdGVSZXNwb25zZUZhbGxiYWNrRW5hYmxlZDogdHJ1ZWAsIG1lc3NhZ2UgaW4gcmVxdWVzdCB0byBgcmVzcG9uc2VfdXJsYCB8IEVtcHR5IHJlc3BvbnNlIHwgTWVzc2FnZSBpbiByZXF1ZXN0IHRvIGByZXNwb25zZV91cmxgIHxcbiAgICogKipEaWFsb2cgU3VibWlzc2lvbioqfCBFcnJvciBsaXN0IGluIHJlc3BvbnNlIHwgRXJyb3IgbGlzdCBpbiByZXNwb25zZSB8IEVtcHR5IHJlc3BvbnNlIHwgTWVzc2FnZSBpbiByZXF1ZXN0IHRvIGByZXNwb25zZV91cmxgIHwgUmV0dXJuaW5nIGEgUHJvbWlzZSB0aGF0IHRha2VzIGxvbmdlciB0aGFuIDMgc2Vjb25kcyB0byByZXNvbHZlIGNhbiByZXN1bHQgaW4gdGhlIHVzZXIgc2VlaW5nIGFuIGVycm9yLiBXYXJuaW5nIGxvZ2dlZCBpZiBhIHByb21pc2UgaXNuJ3QgY29tcGxldGVkIGJlZm9yZSBgc3luY1Jlc3BvbnNlVGltZW91dGAuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fHN0cmluZ3xSZWdFeHB9IG1hdGNoaW5nQ29uc3RyYWludHMgLSB0aGUgY2FsbGJhY2sgSUQgKGFzIGEgc3RyaW5nIG9yIFJlZ0V4cCkgb3JcbiAgICogYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlIGNvbnN0cmFpbnRzIHRvIG1hdGNoIGFjdGlvbnMgZm9yIHRoZSBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IFttYXRjaGluZ0NvbnN0cmFpbnRzLmNhbGxiYWNrSWRdIC0gYSBzdHJpbmcgb3IgUmVnRXhwIHRvIG1hdGNoIGFnYWluc3RcbiAgICogdGhlIGBjYWxsYmFja19pZGBcbiAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBbbWF0Y2hpbmdDb25zdHJhaW50cy5ibG9ja0lkXSAtIGEgc3RyaW5nIG9yIFJlZ0V4cCB0byBtYXRjaCBhZ2FpbnN0XG4gICAqIHRoZSBgYmxvY2tfaWRgXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gW21hdGNoaW5nQ29uc3RyYWludHMuYWN0aW9uSWRdIC0gYSBzdHJpbmcgb3IgUmVnRXhwIHRvIG1hdGNoIGFnYWluc3RcbiAgICogdGhlIGBhY3Rpb25faWRgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWF0Y2hpbmdDb25zdHJhaW50cy50eXBlXSAtIHZhbGlkIHR5cGVzIGluY2x1ZGUgYWxsXG4gICAqIFthY3Rpb25zIGJsb2NrIGVsZW1lbnRzXShodHRwczovL2FwaS5zbGFjay5jb20vcmVmZXJlbmNlL21lc3NhZ2luZy9pbnRlcmFjdGl2ZS1jb21wb25lbnRzKSxcbiAgICogYHNlbGVjdGAgb25seSBmb3IgbWVudSBzZWxlY3Rpb25zLCBvciBgZGlhbG9nX3N1Ym1pc3Npb25gIG9ubHkgZm9yIGRpYWxvZyBzdWJtaXNzaW9uc1xuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFttYXRjaGluZ0NvbnN0cmFpbnRzLnVuZnVybF0gLSB3aGVuIGB0cnVlYCBvbmx5IG1hdGNoIGFjdGlvbnMgZnJvbSBhbiB1bmZ1cmxcbiAgICogQHBhcmFtIHttb2R1bGU6YWRhcHRlcn5TbGFja01lc3NhZ2VBZGFwdGVyfkFjdGlvbkhhbmRsZXJ9IGNhbGxiYWNrIC0gdGhlIGZ1bmN0aW9uIHRvIHJ1biB3aGVuXG4gICAqIGFuIGFjdGlvbiBpcyBtYXRjaGVkXG4gICAqIEByZXR1cm5zIHttb2R1bGU6YWRhcHRlcn5TbGFja01lc3NhZ2VBZGFwdGVyfSAtIHRoaXMgaW5zdGFuY2UgKGZvciBjaGFpbmluZylcbiAgICovXG4gIGFjdGlvbihtYXRjaGluZ0NvbnN0cmFpbnRzLCBjYWxsYmFjaykge1xuICAgIC8qIGVzbGludC1lbmFibGUgbWF4LWxlbiAqL1xuICAgIGNvbnN0IGFjdGlvbkNvbnN0cmFpbnRzID0gZm9ybWF0TWF0Y2hpbmdDb25zdHJhaW50cyhtYXRjaGluZ0NvbnN0cmFpbnRzKTtcbiAgICBhY3Rpb25Db25zdHJhaW50cy5oYW5kbGVyVHlwZSA9ICdhY3Rpb24nO1xuXG4gICAgY29uc3QgZXJyb3IgPSB2YWxpZGF0ZUNvbnN0cmFpbnRzKGFjdGlvbkNvbnN0cmFpbnRzKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGRlYnVnKCdhY3Rpb24gY291bGQgbm90IGJlIHJlZ2lzdGVyZWQ6ICVzJywgZXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5yZWdpc3RlckNhbGxiYWNrKGFjdGlvbkNvbnN0cmFpbnRzLCBjYWxsYmFjayk7XG4gIH1cblxuICAvKiBlc2xpbnQtZGlzYWJsZSBtYXgtbGVuICovXG4gIC8qKlxuICAgKiBBZGQgYSBoYW5kbGVyIGZvciBhbiBvcHRpb25zIHJlcXVlc3RcbiAgICpcbiAgICogVXN1YWxseSB0aGVyZSdzIG5vIG5lZWQgdG8gYmUgY29uY2VybmVkIHdpdGggX2hvd18gYSBtZXNzYWdlIGlzIHNlbnQgdG8gU2xhY2ssIGJ1dCB0aGVcbiAgICogZm9sbG93aW5nIHRhYmxlIGRlc2NyaWJlcyBpdCBmdWxseVxuICAgKlxuICAgKiAmbmJzcDt8KipSZXR1cm4gYG9wdGlvbnNgKip8KipSZXR1cm4gYFByb21pc2U8b3B0aW9ucz5gKip8KipSZXR1cm4gYHVuZGVmaW5lZGAqKnwqKk5vdGVzKipcbiAgICogOi0tLS0tOnw6LS0tLS06fDotLS0tLTp8Oi0tLS0tOnw6LS0tLS06XG4gICAqICoqT3B0aW9ucyBSZXF1ZXN0Kip8IE9wdGlvbnMgaW4gcmVzcG9uc2UgfCBPcHRpb25zIGluIHJlc3BvbnNlIHwgRW1wdHkgcmVzcG9uc2UgfCBSZXR1cm5pbmcgYSBQcm9taXNlIHRoYXQgdGFrZXMgbG9uZ2VyIHRoYW4gMyBzZWNvbmRzIHRvIHJlc29sdmUgY2FuIHJlc3VsdCBpbiB0aGUgdXNlciBzZWVpbmcgYW4gZXJyb3IuIElmIHRoZSByZXF1ZXN0IGlzIGZyb20gd2l0aGluIGEgZGlhbG9nLCB0aGUgYHRleHRgIGZpZWxkIGlzIGNhbGxlZCBgbGFiZWxgLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gbWF0Y2hpbmdDb25zdHJhaW50cyAtIHRoZSBjYWxsYmFjayBJRCAoYXMgYSBzdHJpbmcgb3IgUmVnRXhwKSBvclxuICAgKiBhbiBvYmplY3QgZGVzY3JpYmluZyB0aGUgY29uc3RyYWludHMgdG8gc2VsZWN0IG9wdGlvbnMgcmVxdWVzdHMgZm9yIHRoZSBoYW5kbGVyLlxuICAgKiBAcGFyYW0ge3N0cmluZ3xSZWdFeHB9IFttYXRjaGluZ0NvbnN0cmFpbnRzLmNhbGxiYWNrSWRdIC0gYSBzdHJpbmcgb3IgUmVnRXhwIHRvIG1hdGNoIGFnYWluc3RcbiAgICogdGhlIGBjYWxsYmFja19pZGBcbiAgICogQHBhcmFtIHtzdHJpbmd8UmVnRXhwfSBbbWF0Y2hpbmdDb25zdHJhaW50cy5ibG9ja0lkXSAtIGEgc3RyaW5nIG9yIFJlZ0V4cCB0byBtYXRjaCBhZ2FpbnN0XG4gICAqIHRoZSBgYmxvY2tfaWRgXG4gICAqIEBwYXJhbSB7c3RyaW5nfFJlZ0V4cH0gW21hdGNoaW5nQ29uc3RyYWludHMuYWN0aW9uSWRdIC0gYSBzdHJpbmcgb3IgUmVnRXhwIHRvIG1hdGNoIGFnYWluc3RcbiAgICogdGhlIGBhY3Rpb25faWRgXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWF0Y2hpbmdDb25zdHJhaW50cy53aXRoaW5dIC0gYGJsb2NrX2FjdGlvbnNgIG9ubHkgZm9yIGV4dGVybmFsIHNlbGVjdFxuICAgKiBpbiBhY3Rpb25zIGJsb2NrLCBgaW50ZXJhY3RpdmVfbWVzc2FnZWAgb25seSBmb3IgbWVudXMgaW4gYW4gaW50ZXJhY3RpdmUgbWVzc2FnZSwgb3JcbiAgICogYGRpYWxvZ2Agb25seSBmb3IgbWVudXMgaW4gYSBkaWFsb2dcbiAgICogQHBhcmFtIHttb2R1bGU6YWRhcHRlcn5TbGFja01lc3NhZ2VBZGFwdGVyfk9wdGlvbnNIYW5kbGVyfSBjYWxsYmFjayAtIHRoZSBmdW5jdGlvbiB0byBydW4gd2hlblxuICAgKiBhbiBvcHRpb25zIHJlcXVlc3QgaXMgbWF0Y2hlZFxuICAgKiBAcmV0dXJucyB7bW9kdWxlOmFkYXB0ZXJ+U2xhY2tNZXNzYWdlQWRhcHRlcn0gLSB0aGlzIGluc3RhbmNlIChmb3IgY2hhaW5pbmcpXG4gICAqL1xuICBvcHRpb25zKG1hdGNoaW5nQ29uc3RyYWludHMsIGNhbGxiYWNrKSB7XG4gICAgLyogZXNsaW50LWVuYWJsZSBtYXgtbGVuICovXG4gICAgY29uc3Qgb3B0aW9uc0NvbnN0cmFpbnRzID0gZm9ybWF0TWF0Y2hpbmdDb25zdHJhaW50cyhtYXRjaGluZ0NvbnN0cmFpbnRzKTtcbiAgICBvcHRpb25zQ29uc3RyYWludHMuaGFuZGxlclR5cGUgPSAnb3B0aW9ucyc7XG5cbiAgICBjb25zdCBlcnJvciA9IHZhbGlkYXRlQ29uc3RyYWludHMob3B0aW9uc0NvbnN0cmFpbnRzKSB8fFxuICAgICAgdmFsaWRhdGVPcHRpb25zQ29uc3RyYWludHMob3B0aW9uc0NvbnN0cmFpbnRzKTtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIGRlYnVnKCdvcHRpb25zIGNvdWxkIG5vdCBiZSByZWdpc3RlcmVkOiAlcycsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMucmVnaXN0ZXJDYWxsYmFjayhvcHRpb25zQ29uc3RyYWludHMsIGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qIEludGVyZmFjZSBmb3IgSFRUUCBzZXJ2ZXJzIChsaWtlIGV4cHJlc3MgbWlkZGxld2FyZSkgKi9cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyB0aGUgY29udGVudHMgb2YgYW4gSFRUUCByZXF1ZXN0IHRvIHRoZSByZWdpc3RlcmVkIGhhbmRsZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge29iamVjdH0gcGF5bG9hZFxuICAgKiBAcmV0dXJucyB7UHJvbWlzZTx7IHN0YXR1czogbnVtYmVyLCBjb250ZW50OiBvYmplY3R8c3RyaW5nfHVuZGVmaW5lZCB9Pnx1bmRlZmluZWR9IC0gQSBwcm9taXNlXG4gICAqIG9mIHRoZSByZXNwb25zZSBpbmZvcm1hdGlvbiAoYW4gb2JqZWN0IHdpdGggc3RhdHVzIGFuZCBjb250ZW50IHRoYXQgaXMgYSBKU09OIHNlcmlhbGl6YWJsZVxuICAgKiBvYmplY3Qgb3IgYSBzdHJpbmcgb3IgdW5kZWZpbmVkKSBmb3IgdGhlIHJlcXVlc3QuIEFuIHVuZGVmaW5lZCByZXR1cm4gdmFsdWUgaW5kaWNhdGVzIHRoYXQgdGhlXG4gICAqIHJlcXVlc3Qgd2FzIG5vdCBtYXRjaGVkLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzcGF0Y2gocGF5bG9hZCkge1xuICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5tYXRjaENhbGxiYWNrKHBheWxvYWQpO1xuICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgIGRlYnVnKCdkaXNwYXRjaCBjb3VsZCBub3QgZmluZCBhIGhhbmRsZXInKTtcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGRlYnVnKCdkaXNwYXRjaGluZyB0byBoYW5kbGVyJyk7XG4gICAgY29uc3QgWywgY2FsbGJhY2tGbl0gPSBjYWxsYmFjaztcblxuICAgIC8vIHdoZW4gYSByZXNwb25zZV91cmwgaXMgcHJlc2VudCxgcmVzcG9uZCgpYCBmdW5jdGlvbiBjcmVhdGVkIHRvIHRvIHNlbmQgYSBtZXNzYWdlIHVzaW5nIGl0XG4gICAgbGV0IHJlc3BvbmQ7XG4gICAgaWYgKHBheWxvYWQucmVzcG9uc2VfdXJsKSB7XG4gICAgICByZXNwb25kID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgdXNlIGEgUHJvbWlzZSBhcyB0aGUgcGFyYW1ldGVyIGZvciByZXNwb25kKCknKTtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1Zygnc2VuZGluZyBhc3luYyByZXNwb25zZScpO1xuICAgICAgICByZXR1cm4gdGhpcy5heGlvcy5wb3N0KHBheWxvYWQucmVzcG9uc2VfdXJsLCBtZXNzYWdlKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgbGV0IGNhbGxiYWNrUmVzdWx0O1xuICAgIHRyeSB7XG4gICAgICBjYWxsYmFja1Jlc3VsdCA9IGNhbGxiYWNrRm4uY2FsbCh0aGlzLCBwYXlsb2FkLCByZXNwb25kKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgZGVidWcoJ2NhbGxiYWNrIGVycm9yOiAlbycsIGVycm9yKTtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBzdGF0dXM6IDUwMCB9KTtcbiAgICB9XG5cbiAgICBpZiAoY2FsbGJhY2tSZXN1bHQpIHtcbiAgICAgIHJldHVybiBwcm9taXNlVGltZW91dCh0aGlzLnN5bmNSZXNwb25zZVRpbWVvdXQsIGNhbGxiYWNrUmVzdWx0KVxuICAgICAgICAudGhlbihjb250ZW50ID0+ICh7IHN0YXR1czogMjAwLCBjb250ZW50IH0pKVxuICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IHV0aWxFcnJvckNvZGVzLlBST01JU0VfVElNRU9VVCkge1xuICAgICAgICAgICAgLy8gd2FybiBhbmQgY29udGludWUgZm9yIHByb21pc2VzIHRoYXQgY2Fubm90IGJlIHNhdmVkIHdpdGggYSBsYXRlciBhc3luYyByZXNwb25zZS5cbiAgICAgICAgICAgIC8vIHRoaXMgaW5jbHVkZXMgZGlhbG9nIHN1Ym1pc3Npb25zIGJlY2F1c2UgdGhlIHJlc3BvbnNlX3VybCBkb2Vzbid0IGhhdmUgdGhlIHNhbWVcbiAgICAgICAgICAgIC8vIHNlbWFudGljcyBhcyB0aGUgcmVzcG9uc2UsIGFueSByZXF1ZXN0IHRoYXQgZG9lc24ndCBjb250YWluIGEgcmVzcG9uc2VfdXJsLCBhbmRcbiAgICAgICAgICAgIC8vIGlmIHRoaXMgaGFzIGJlZW4gZXhwbGljaXRseSBkaXNhYmxlZCBpbiB0aGUgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICAgIGlmICghdGhpcy5sYXRlUmVzcG9uc2VGYWxsYmFja0VuYWJsZWQgfHwgIXJlc3BvbmQgfHwgcGF5bG9hZC50eXBlID09PSAnZGlhbG9nX3N1Ym1pc3Npb24nKSB7XG4gICAgICAgICAgICAgIGRlYnVnKCdXQVJOSU5HOiBUaGUgcmVzcG9uc2UgUHJvbWlzZSBkaWQgbm90IHJlc29sdmUgdW5kZXIgdGhlIHRpbWVvdXQuJyk7XG4gICAgICAgICAgICAgIHJldHVybiBjYWxsYmFja1Jlc3VsdFxuICAgICAgICAgICAgICAgIC50aGVuKGNvbnRlbnQgPT4gKHsgc3RhdHVzOiAyMDAsIGNvbnRlbnQgfSkpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+ICh7IHN0YXR1czogNTAwIH0pKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2F2ZSBhIGxhdGUgcHJvbWlzZSBieSBzZW5kaW5nIGFuIGVtcHR5IGJvZHkgaW4gdGhlIHJlc3BvbnNlLCBhbmQgdGhlbiB1c2UgdGhlXG4gICAgICAgICAgICAvLyByZXNwb25zZV91cmwgdG8gc2VuZCB0aGUgZXZlbnR1YWxseSByZXNvbHZlZCB2YWx1ZVxuICAgICAgICAgICAgY2FsbGJhY2tSZXN1bHQudGhlbihyZXNwb25kKS5jYXRjaCgoY2FsbGJhY2tFcnJvcikgPT4ge1xuICAgICAgICAgICAgICAvLyB3aGVuIHRoZSBwcm9taXNlIGlzIGxhdGUgYW5kIGZhaWxzLCB3ZSBjYW5ub3QgZG8gYW55dGhpbmcgYnV0IGxvZyBpdFxuICAgICAgICAgICAgICBkZWJ1ZygnRVJST1I6IFByb21pc2Ugd2FzIGxhdGUgYW5kIGZhaWxlZC4gVXNlIGAuY2F0Y2goKWAgdG8gaGFuZGxlIGVycm9ycy4nKTtcbiAgICAgICAgICAgICAgdGhyb3cgY2FsbGJhY2tFcnJvcjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgc3RhdHVzOiAyMDAgfTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4geyBzdGF0dXM6IDUwMCB9O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZm9sbG93aW5nIHJlc3VsdCB2YWx1ZSByZXByZXNlbnRzOlxuICAgIC8vICogXCJubyByZXBsYWNlbWVudFwiIGZvciBtZXNzYWdlIGFjdGlvbnNcbiAgICAvLyAqIFwic3VibWlzc2lvbiBpcyB2YWxpZFwiIGZvciBkaWFsb2cgc3VibWlzc2lvbnNcbiAgICAvLyAqIFwibm8gc3VnZ2VzdGlvbnNcIiBmb3IgbWVudSBvcHRpb25zIFRPRE86IGNoZWNrIHRoYXQgdGhpcyBpcyB0cnVlXG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IHN0YXR1czogMjAwIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICByZWdpc3RlckNhbGxiYWNrKGNvbnN0cmFpbnRzLCBjYWxsYmFjaykge1xuICAgIC8vIFZhbGlkYXRpb25cbiAgICBpZiAoIWlzRnVuY3Rpb24oY2FsbGJhY2spKSB7XG4gICAgICBkZWJ1ZygnZGlkIG5vdCByZWdpc3RlciBjYWxsYmFjayBiZWNhdXNlIGl0cyBub3QgYSBmdW5jdGlvbicpO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FsbGJhY2sgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgdGhpcy5jYWxsYmFja3MucHVzaChbY29uc3RyYWludHMsIGNhbGxiYWNrXSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbWF0Y2hDYWxsYmFjayhwYXlsb2FkKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tzLmZpbmQoKFtjb25zdHJhaW50c10pID0+IHtcbiAgICAgIC8vIGlmIHRoZSBjYWxsYmFjayBJRCBjb25zdHJhaW50IGlzIHNwZWNpZmllZCwgb25seSBjb250aW51ZSBpZiBpdCBtYXRjaGVzXG4gICAgICBpZiAoY29uc3RyYWludHMuY2FsbGJhY2tJZCkge1xuICAgICAgICBpZiAoaXNTdHJpbmcoY29uc3RyYWludHMuY2FsbGJhY2tJZCkgJiYgcGF5bG9hZC5jYWxsYmFja19pZCAhPT0gY29uc3RyYWludHMuY2FsbGJhY2tJZCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNSZWdFeHAoY29uc3RyYWludHMuY2FsbGJhY2tJZCkgJiYgIWNvbnN0cmFpbnRzLmNhbGxiYWNrSWQudGVzdChwYXlsb2FkLmNhbGxiYWNrX2lkKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGUgYWN0aW9uIGNvbnN0cmFpbnQgaXMgc3BlY2lmaWVkLCBvbmx5IGNvbnRpbnVlIGlmIGl0IG1hdGNoZXNcbiAgICAgIGlmIChjb25zdHJhaW50cy5oYW5kbGVyVHlwZSA9PT0gJ2FjdGlvbicpIHtcbiAgICAgICAgLy8gYSBwYXlsb2FkIHRoYXQgcmVwcmVzZW50cyBhbiBhY3Rpb24gZWl0aGVyIGhhcyBhY3Rpb25zLCBzdWJtaXNzaW9uLCBvciBtZXNzYWdlIGRlZmluZWRcbiAgICAgICAgaWYgKCEocGF5bG9hZC5hY3Rpb25zIHx8IHBheWxvYWQuc3VibWlzc2lvbiB8fCBwYXlsb2FkLm1lc3NhZ2UpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGlhbG9nIHN1Ym1pc3Npb25zIGRvbid0IGhhdmUgYW4gYWN0aW9uIGRlZmluZWQsIHNvIGFuIGVtcHR5IGFjdGlvbiBpcyBzdWJzdGl0dXRlZCBmb3JcbiAgICAgICAgLy8gdGhlIHB1cnBvc2Ugb2YgY2FsbGJhY2sgbWF0Y2hpbmdcbiAgICAgICAgY29uc3QgYWN0aW9uID0gcGF5bG9hZC5hY3Rpb25zID8gcGF5bG9hZC5hY3Rpb25zWzBdIDoge307XG5cbiAgICAgICAgLy8gaWYgdGhlIGJsb2NrIElEIGNvbnN0cmFpbnQgaXMgc3BlY2lmaWVkLCBvbmx5IGNvbnRpbnVlIGlmIGl0IG1hdGNoZXNcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmJsb2NrSWQpIHtcbiAgICAgICAgICBpZiAoaXNTdHJpbmcoY29uc3RyYWludHMuYmxvY2tJZCkgJiYgYWN0aW9uLmJsb2NrX2lkICE9PSBjb25zdHJhaW50cy5ibG9ja0lkKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpc1JlZ0V4cChjb25zdHJhaW50cy5ibG9ja0lkKSAmJiAhY29uc3RyYWludHMuYmxvY2tJZC50ZXN0KGFjdGlvbi5ibG9ja19pZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgYWN0aW9uIElEIGNvbnN0cmFpbnQgaXMgc3BlY2lmaWVkLCBvbmx5IGNvbnRpbnVlIGlmIGl0IG1hdGNoZXNcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFjdGlvbklkKSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKGNvbnN0cmFpbnRzLmFjdGlvbklkKSAmJiBhY3Rpb24uYWN0aW9uX2lkICE9PSBjb25zdHJhaW50cy5hY3Rpb25JZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNSZWdFeHAoY29uc3RyYWludHMuYWN0aW9uSWQpICYmICFjb25zdHJhaW50cy5hY3Rpb25JZC50ZXN0KGFjdGlvbi5hY3Rpb25faWQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYnV0dG9uIGFuZCBtZXNzYWdlIGFjdGlvbnMgaGF2ZSBhIHR5cGUgZGVmaW5lZCBpbnNpZGUgdGhlIGFjdGlvbiwgZGlhbG9nIHN1Ym1pc3Npb25cbiAgICAgICAgLy8gYWN0aW9ucyBoYXZlIGEgdHlwZSBkZWZpbmVkIGF0IHRoZSB0b3AgbGV2ZWwsIGFuZCBzZWxlY3QgYWN0aW9ucyBkb24ndCBoYXZlIGEgdHlwZVxuICAgICAgICAvLyBkZWZpbmVkLCBidXQgdHlwZSBjYW4gYmUgaW5mZXJyZWQgYnkgY2hlY2tpbmcgaWYgYSBgc2VsZWN0ZWRfb3B0aW9uc2AgcHJvcGVydHkgZXhpc3RzIGluXG4gICAgICAgIC8vIHRoZSBhY3Rpb24uXG4gICAgICAgIGNvbnN0IHR5cGUgPSBhY3Rpb24udHlwZSB8fCBwYXlsb2FkLnR5cGUgfHwgKGFjdGlvbi5zZWxlY3RlZF9vcHRpb25zICYmICdzZWxlY3QnKTtcbiAgICAgICAgaWYgKCF0eXBlKSB7XG4gICAgICAgICAgZGVidWcoJ25vIHR5cGUgZm91bmQgaW4gZGlzcGF0Y2hlZCBhY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBpZiB0aGUgdHlwZSBjb25zdHJhaW50IGlzIHNwZWNpZmllZCwgb25seSBjb250aW51ZSBpZiBpdCBtYXRjaGVzXG4gICAgICAgIGlmIChjb25zdHJhaW50cy50eXBlICYmIGNvbnN0cmFpbnRzLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgdW5mdXJsIGNvbnN0cmFpbnQgaXMgc3BlY2lmaWVkLCBvbmx5IGNvbnRpbnVlIGlmIGl0IG1hdGNoZXNcbiAgICAgICAgaWYgKCd1bmZ1cmwnIGluIGNvbnN0cmFpbnRzICYmXG4gICAgICAgICAgKFxuICAgICAgICAgICAgKGNvbnN0cmFpbnRzLnVuZnVybCAmJiAhcGF5bG9hZC5pc19hcHBfdW5mdXJsKSB8fFxuICAgICAgICAgICAgKCFjb25zdHJhaW50cy51bmZ1cmwgJiYgcGF5bG9hZC5pc19hcHBfdW5mdXJsKVxuICAgICAgICAgIClcbiAgICAgICAgKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb25zdHJhaW50cy5oYW5kbGVyVHlwZSA9PT0gJ29wdGlvbnMnKSB7XG4gICAgICAgIC8vIGEgcGF5bG9hZCB0aGF0IHJlcHJlc2VudHMgYW4gb3B0aW9ucyByZXF1ZXN0IGluIGF0dGFjaG1lbnRzIGFsd2F5cyBoYXMgYSBuYW1lIGRlZmluZWRcbiAgICAgICAgLy8gYXQgdGhlIHRvcCBsZXZlbC4gaW4gYmxvY2tzIHRoZSB0eXBlIGlzIGJsb2NrX3N1Z2dlc3Rpb24gYW5kIGhhcyBubyBuYW1lXG4gICAgICAgIGlmICghKCduYW1lJyBpbiBwYXlsb2FkIHx8IChwYXlsb2FkLnR5cGUgJiYgcGF5bG9hZC50eXBlID09PSAnYmxvY2tfc3VnZ2VzdGlvbicpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSBibG9jayBJRCBjb25zdHJhaW50IGlzIHNwZWNpZmllZCwgb25seSBjb250aW51ZSBpZiBpdCBtYXRjaGVzXG4gICAgICAgIGlmIChjb25zdHJhaW50cy5ibG9ja0lkKSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKGNvbnN0cmFpbnRzLmJsb2NrSWQpICYmIHBheWxvYWQuYmxvY2tfaWQgIT09IGNvbnN0cmFpbnRzLmJsb2NrSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUmVnRXhwKGNvbnN0cmFpbnRzLmJsb2NrSWQpICYmICFjb25zdHJhaW50cy5ibG9ja0lkLnRlc3QocGF5bG9hZC5ibG9ja19pZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpZiB0aGUgYWN0aW9uIElEIGNvbnN0cmFpbnQgaXMgc3BlY2lmaWVkLCBvbmx5IGNvbnRpbnVlIGlmIGl0IG1hdGNoZXNcbiAgICAgICAgaWYgKGNvbnN0cmFpbnRzLmFjdGlvbklkKSB7XG4gICAgICAgICAgaWYgKGlzU3RyaW5nKGNvbnN0cmFpbnRzLmFjdGlvbklkKSAmJiBwYXlsb2FkLmFjdGlvbl9pZCAhPT0gY29uc3RyYWludHMuYWN0aW9uSWQpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGlzUmVnRXhwKGNvbnN0cmFpbnRzLmFjdGlvbklkKSAmJiAhY29uc3RyYWludHMuYWN0aW9uSWQudGVzdChwYXlsb2FkLmFjdGlvbl9pZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhbiBvcHRpb25zIHJlcXVlc3QgYWx3YXlzIGhhcyBhIHR5cGUgYXQgdGhlIHRvcCBsZXZlbCB3aGljaCBjYW4gYmUgb25lIG9mIHRocmVlIHZhbHVlc1xuICAgICAgICAvLyB0aGF0IG5lZWQgdG8gYmUgbWFwcGVkIGludG8gdGhlIHZhbHVlcyBmb3IgdGhlIGB3aXRoaW5gIGNvbnN0cmFpbnQ6XG4gICAgICAgIC8vICogdHlwZTppbnRlcmFjdGl2ZV9tZXNzYWdlID0+IHdpdGhpbjppbnRlcmFjdGl2ZV9tZXNzYWdlXG4gICAgICAgIC8vICogdHlwZTpibG9ja19zdWdnZXN0aW9uID0+IHdpdGhpbjpibG9ja19hY3Rpb25zXG4gICAgICAgIC8vICogdHlwZTpkaWFsb2dfc3VnZ2VzdGlvbiA9PiB3aXRoaW46ZGlhbG9nXG4gICAgICAgIGlmIChjb25zdHJhaW50cy53aXRoaW4pIHtcbiAgICAgICAgICBpZiAoY29uc3RyYWludHMud2l0aGluID09PSAnaW50ZXJhY3RpdmVfbWVzc2FnZScgJiYgcGF5bG9hZC50eXBlICE9PSAnaW50ZXJhY3RpdmVfbWVzc2FnZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbnN0cmFpbnRzLndpdGhpbiA9PT0gJ2Jsb2NrX2FjdGlvbnMnICYmIHBheWxvYWQudHlwZSAhPT0gJ2Jsb2NrX3N1Z2dlc3Rpb24nKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChjb25zdHJhaW50cy53aXRoaW4gPT09ICdkaWFsb2cnICYmIHBheWxvYWQudHlwZSAhPT0gJ2RpYWxvZ19zdWdnZXN0aW9uJykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBpZiB0aGVyZSdzIG5vIHJlYXNvbiB0byBlbGltaW5hdGUgdGhpcyBjYWxsYmFjaywgdGhlbiBpdHMgYSBtYXRjaCFcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogQGFsaWFzIG1vZHVsZTphZGFwdGVyXG4gKi9cbmV4cG9ydCBkZWZhdWx0IFNsYWNrTWVzc2FnZUFkYXB0ZXI7XG5cbi8qKlxuICogQGV4dGVybmFsIEV4cHJlc3NNaWRkbGV3YXJlRnVuY1xuICogQHNlZSBodHRwOi8vZXhwcmVzc2pzLmNvbS9lbi9ndWlkZS91c2luZy1taWRkbGV3YXJlLmh0bWxcbiAqL1xuXG4vKipcbiAqIEBleHRlcm5hbCBOb2RlSHR0cFNlcnZlclxuICogQHNlZSBodHRwczovL25vZGVqcy5vcmcvZGlzdC9sYXRlc3QvZG9jcy9hcGkvaHR0cC5odG1sI2h0dHBfY2xhc3NfaHR0cF9zZXJ2ZXJcbiAqL1xuXG4vKipcbiAqIEEgaGFuZGxlciBmdW5jdGlvbiBmb3IgYWN0aW9uIHJlcXVlc3RzIChibG9jayBhY3Rpb25zLCBidXR0b24gcHJlc3NlcywgbWVudSBzZWxlY3Rpb25zLFxuICogYW5kIGRpYWxvZyBzdWJtaXNzaW9ucykuXG4gKlxuICogQG5hbWUgbW9kdWxlOmFkYXB0ZXJ+U2xhY2tNZXNzYWdlQWRhcHRlcn5BY3Rpb25IYW5kbGVyXG4gKiBAZnVuY3Rpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXlsb2FkIC0gYW4gb2JqZWN0IGRlc2NyaWJpbmcgdGhlXG4gKiBbYmxvY2sgYWN0aW9uc10oaHR0cHM6Ly9hcGkuc2xhY2suY29tL21lc3NhZ2luZy9pbnRlcmFjdGl2aXR5L2VuYWJsaW5nI3VuZGVyc3RhbmRpbmctcGF5bG9hZHMpXG4gKiBbYnV0dG9uIHByZXNzXShodHRwczovL2FwaS5zbGFjay5jb20vZG9jcy9tZXNzYWdlLWJ1dHRvbnMjcmVzcG9uZGluZ190b19tZXNzYWdlX2FjdGlvbnMpLFxuICogW21lbnUgc2VsZWN0aW9uXShodHRwczovL2FwaS5zbGFjay5jb20vZG9jcy9tZXNzYWdlLW1lbnVzI3JlcXVlc3RfdXJsX3Jlc3BvbnNlKSwgb3JcbiAqIFtkaWFsb2cgc3VibWlzc2lvbl0oaHR0cHM6Ly9hcGkuc2xhY2suY29tL2RpYWxvZ3MjZXZhbHVhdGluZ19zdWJtaXNzaW9uX3Jlc3BvbnNlcykuXG4gKiBAcGFyYW0ge21vZHVsZTphZGFwdGVyflNsYWNrTWVzc2FnZUFkYXB0ZXJ+QWN0aW9uSGFuZGxlcn5SZXNwb25kfSByZXNwb25kIC0gV2hlbiB0aGUgYWN0aW9uIGlzIGFcbiAqIGJ1dHRvbiBwcmVzcyBvciBtZW51IHNlbGVjdGlvbiwgdGhpcyBmdW5jdGlvbiBpcyB1c2VkIHRvIHVwZGF0ZSB0aGUgbWVzc2FnZSB3aGVyZSB0aGUgYWN0aW9uXG4gKiBvY2N1cmVkIG9yIGNyZWF0ZSBuZXcgbWVzc2FnZXMgaW4gdGhlIHNhbWUgY29udmVyc2F0aW9uLiBXaGVuIHRoZSBhY3Rpb24gaXMgYSBkaWFsb2cgc3VibWlzc2lvbixcbiAqIHRoaXMgZnVuY3Rpb24gaXMgdXNlZCB0byBjcmVhdGUgbmV3IG1lc3NhZ2VzIGluIHRoZSBjb252ZXJzYXRpb24gd2hlcmUgdGhlIGRpYWxvZyB3YXMgdHJpZ2dlcmVkLlxuICogQHJldHVybnMge09iamVjdH0gV2hlbiB0aGUgYWN0aW9uIGlzIGEgYnV0dG9uIHByZXNzIG9yIGEgbWVudSBzZWxlY3Rpb24sIHRoaXMgb2JqZWN0IGlzIGFcbiAqIHJlcGxhY2VtZW50XG4gKiBbbWVzc2FnZV0oaHR0cHM6Ly9hcGkuc2xhY2suY29tL2RvY3MvaW50ZXJhY3RpdmUtbWVzc2FnZS1maWVsZC1ndWlkZSN0b3AtbGV2ZWxfbWVzc2FnZV9maWVsZHMpXG4gKiBmb3IgdGhlIG1lc3NhZ2UgaW4gd2hpY2ggdGhlIGFjdGlvbiBvY2N1cnJlZC4gSXQgbWF5IGFsc28gYmUgYSBQcm9taXNlIGZvciBhIG1lc3NhZ2UsIGFuZCBpZiBzb1xuICogYW5kIHRoZSBQcm9taXNlIHRha2VzIGxvbmdlciB0aGFuIHRoZSBgc3luY1Jlc3BvbnNlVGltZW91dGAgdG8gY29tcGxldGUsIHRoZSBtZXNzYWdlIGlzIHNlbnQgb3ZlclxuICogdGhlIGByZXNwb25zZV91cmxgLiBUaGUgbWVzc2FnZSBtYXkgYWxzbyBiZSBhIG5ldyBtZXNzYWdlIGluIHRoZSBzYW1lIGNvbnZlcnNhdGlvbiBieSBzZXR0aW5nXG4gKiBgcmVwbGFjZV9vcmlnaW5hbDogZmFsc2VgLiBXaGVuIHRoZSBhY3Rpb24gaXMgYSBkaWFsb2cgc3VibWlzc2lvbiwgdGhpcyBvYmplY3QgaXMgYSBsaXN0IG9mXG4gKiBbdmFsaWRhdGlvbiBlcnJvcnNdKGh0dHBzOi8vYXBpLnNsYWNrLmNvbS9kaWFsb2dzI2lucHV0X3ZhbGlkYXRpb24pLiBJdCBtYXkgYWxzbyBiZSBhIFByb21pc2UgZm9yXG4gKiBhIGxpc3Qgb2YgdmFsaWRhdGlvbiBlcnJvcnMsIGFuZCBpZiBzbyBhbmQgdGhlIFByb21pc2UgdGFrZXMgbG9uZ2VyIHRoYW4gdGhlXG4gKiBgc3luY1JlcG9uc2VUaW1lb3V0YCB0byBjb21wbGV0ZSwgU2xhY2sgd2lsbCBkaXNwbHkgYW4gZXJyb3IgdG8gdGhlIHVzZXIuIElmIHRoZXJlIGlzIG5vIHJldHVyblxuICogdmFsdWUsIHRoZW4gYnV0dG9uIHByZXNzZXMgYW5kIG1lbnUgc2VsZWN0aW9ucyBkbyBub3QgdXBkYXRlIHRoZSBtZXNzYWdlIGFuZCBkaWFsb2cgc3VibWlzc2lvbnNcbiAqIHdpbGwgdmFsaWRhdGUgYW5kIGRpc21pc3MuXG4gKi9cblxuLyoqXG4gKiBBIGZ1bmN0aW9uIHVzZWQgdG8gc2VuZCBtZXNzYWdlIHVwZGF0ZXMgYWZ0ZXIgYW4gYWN0aW9uIGlzIGhhbmRsZWQuIFRoaXMgZnVuY3Rpb24gY2FuIGJlIHVzZWRcbiAqIHVwIHRvIDUgdGltZXMgaW4gMzAgbWludXRlcy5cbiAqXG4gKiBAbmFtZSBtb2R1bGU6YWRhcHRlcn5TbGFja01lc3NhZ2VBZGFwdGVyfkFjdGlvbkhhbmRsZXJ+UmVzcG9uZFxuICogQGZ1bmN0aW9uXG4gKiBAcGFyYW0ge09iamVjdH0gbWVzc2FnZSAtIGFcbiAqIFttZXNzYWdlXShodHRwczovL2FwaS5zbGFjay5jb20vZG9jcy9pbnRlcmFjdGl2ZS1tZXNzYWdlLWZpZWxkLWd1aWRlI3RvcC1sZXZlbF9tZXNzYWdlX2ZpZWxkcykuXG4gKiBEaWFsb2cgc3VibWlzc2lvbnMgZG8gbm90IGFsbG93IGByZXNwbGFjZV9vcmlnaW5hbDogZmFsc2VgIG9uIHRoaXMgbWVzc2FnZS5cbiAqIEByZXR1cm5zIHtQcm9taXNlfSB0aGVyZSdzIG5vIGNvbnRyYWN0IG9yIGludGVyZmFjZSBmb3IgdGhlIHJlc29sdXRpb24gdmFsdWUsIGJ1dCB0aGlzIFByb21pc2VcbiAqIHdpbGwgcmVzb2x2ZSB3aGVuIHRoZSBIVFRQIHJlc3BvbnNlIGZyb20gdGhlIGByZXNwb25zZV91cmxgIHJlcXVlc3QgaXMgY29tcGxldGUgYW5kIHJlamVjdCB3aGVuXG4gKiB0aGVyZSBpcyBhbiBlcnJvci5cbiAqL1xuXG4vKipcbiAqIEEgaGFuZGxlciBmdW5jdGlvbiBmb3IgbWVudSBvcHRpb25zIHJlcXVlc3RzLlxuICpcbiAqIEBuYW1lIG1vZHVsZTphZGFwdGVyflNsYWNrTWVzc2FnZUFkYXB0ZXJ+T3B0aW9uc0hhbmRsZXJcbiAqIEBmdW5jdGlvblxuICogQHBhcmFtIHtPYmplY3R9IHBheWxvYWQgLSBhbiBvYmplY3QgZGVzY3JpYmluZ1xuICogW3RoZSBzdGF0ZSBvZiB0aGUgbWVudV0oaHR0cHM6Ly9hcGkuc2xhY2suY29tL2RvY3MvbWVzc2FnZS1tZW51cyNvcHRpb25zX2xvYWRfdXJsKVxuICogQHJldHVybnMge09iamVjdH0gYW5cbiAqIFtvcHRpb25zIGxpc3RdKGh0dHBzOi8vYXBpLnNsYWNrLmNvbS9kb2NzL2ludGVyYWN0aXZlLW1lc3NhZ2UtZmllbGQtZ3VpZGUjb3B0aW9uX2ZpZWxkcykgb3JcbiAqIFtvcHRpb24gZ3JvdXBzIGxpc3RdKGh0dHBzOi8vYXBpLnNsYWNrLmNvbS9kb2NzL2ludGVyYWN0aXZlLW1lc3NhZ2UtZmllbGQtZ3VpZGUjb3B0aW9uX2dyb3VwcykuXG4gKiBXaGVuIHRoZSBtZW51IGlzIHdpdGhpbiBhbiBpbnRlcmFjdGl2ZSBtZXNzYWdlLCAoYHdpdGhpbjogJ2ludGVyYWN0aXZlX21lc3NhZ2UnYCkgdGhlIG9wdGlvblxuICoga2V5cyBhcmUgYHRleHRgIGFuZCBgdmFsdWVgLiBXaGVuIHRoZSBtZW51IGlzIHdpdGhpbiBhIGRpYWxvZyAoYHdpdGhpbjogJ2RpYWxvZydgKSB0aGUgb3B0aW9uXG4gKiBrZXlzIGFyZSBgbGFiZWxgIGFuZCBgdmFsdWVgLiBXaGVuIHRoZSBtZW51IGlzIHdpdGhpbiBhIGRpYWxvZyAoYHdpdGhpbjogJ2Jsb2NrX2FjdGlvbnMnYCkgdGhlXG4gKiBvcHRpb24ga2V5cyBhcmUgYSB0ZXh0IGJsb2NrIGFuZCBgdmFsdWVgLiBUaGlzIGZ1bmN0aW9uIG1heSBhbHNvIHJldHVybiBhIFByb21pc2UgZWl0aGVyIG9mXG4gKiB0aGVzZSB2YWx1ZXMuIElmIGEgUHJvbWlzZSBpcyByZXR1cm5lZCBhbmQgaXQgZG9lcyBub3QgY29tcGxldGUgd2l0aGluIDMgc2Vjb25kcywgU2xhY2sgd2lsbFxuICogZGlzcGxheSBhbiBlcnJvciB0byB0aGUgdXNlci4gSWYgdGhlcmUgaXMgbm8gcmV0dXJuIHZhbHVlLCB0aGVuIHRoZSB1c2VyIGlzIHNob3duIGFuIGVtcHR5IGxpc3RcbiAqIG9mIG9wdGlvbnMuXG4gKi9cbiJdfQ==
//# sourceMappingURL=adapter.js.map